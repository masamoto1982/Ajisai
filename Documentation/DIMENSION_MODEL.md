# Ajisai 次元モデル仕様

## Ajisaiの「3」の原則

Ajisaiは一貫した「3」の原則に基づいて設計されています：

| 制限 | 値 | 説明 |
|------|-----|------|
| 可視次元 | 3 | `{ ( [ ] ) }` まで |
| 呼び出し深度 | 3 | `A -> B -> C` まで |

この制限により、コードの複雑さを抑制し、スタックオーバーフローを防止します。

## 次元構造

Ajisaiは「0次元を含めて4次元」をサポートする。可視は3次元まで。

| 次元 | 括弧 | 可視性 | 説明 |
|------|------|--------|------|
| 0次元 | `[ ]` | 不可視 | スタック（GUIの枠そのもの） |
| 1次元 | `{ }` | 可視 | 最外殻 |
| 2次元 | `( )` | 可視 | 2番目のネスト |
| 3次元 | `[ ]` | 可視 | 最深のネスト（限界） |
| 4次元〜 | — | — | エラー |

## 0次元：スタック

スタックは暗黙の最外殻Vectorとして機能する。

- GUIには表示されない
- `..` オペレーションターゲットは0次元への操作
- スタック上の各要素は1次元のVectorとして扱われる

### 表示例

スタック上に以下の値があるとき：
```
内部表現: [ { ( [ 1 2 3 ] ) } { ( [ 4 5 6 ] ) } ]
           ^0次元（不可視）
             ^1次元        ^1次元
GUI表示:    { ( [ 1 2 3 ] ) } { ( [ 4 5 6 ] ) }
```

## 次元制限

3次元を超えるネスト（4次元以上）を作成しようとするとエラーになる：
```
Dimension limit exceeded: Ajisai supports up to 3 visible dimensions
(plus dimension 0: the stack). Nesting depth 4 exceeds the limit.
```

## 括弧表示ルール

| 深さ（可視） | 括弧 |
|-------------|------|
| 1次元 | `{ }` |
| 2次元 | `( )` |
| 3次元 | `[ ]` |

入力時は `[]`, `{}`, `()` のいずれも同等に扱われ、表示時に深さに応じて変換される。

## NILの扱い

**空ブラケット `[ ]` はエラーになります。** NILが必要な場合は `NIL` キーワードを使用してください。

```ajisai
[ ]                    # → エラー: Empty vector is not allowed
NIL                    # → NIL（センチネル値 0/0）
[ 1 NIL 3 ]            # → NILを要素として持つVector
```

NILに対する操作：
- `NIL LENGTH` → `[ 0 ]` （長さ0）
- `NIL 'WORD' MAP` → `NIL` （NILをマップしてもNIL）
- `NIL [ 42 ] '+' FOLD` → `[ 42 ]` （初期値がそのまま返る）

### NILの内部表現

NILはセンチネル分数（0/0）を持つスカラー値として表現されます：
- `data: [Fraction(0/0)]`
- `shape: []`（スカラー）
- `display_hint: DisplayHint::Nil`

これにより、Vector内にNILを要素として格納することが可能です。

## 基本概念

### 形状（Shape）
- 各次元のサイズを表すベクタ
- `{ 1 2 3 }` の形状は `{ 3 }`
- `{ ( 1 2 3 ) ( 4 5 6 ) }` の形状は `{ 2 3 }`

### 矩形制約
- 同一次元内の要素は同じ形状でなければならない
- `{ ( 1 2 ) ( 3 4 5 ) }` は不正（行の長さが不一致）

## 演算のブロードキャスト

詳細は `BROADCASTING.md` を参照。

NumPy/APLと同様のブロードキャスト規則に従い、形状の異なるテンソル間の演算を可能にする。

## 軸の命名（未確定）

各次元の意味付け（軸名）は用途に応じて解釈される。
現時点では汎用的な「次元0」「次元1」「次元2」「次元3」として扱う。

## 入力支援ワード

### FRAME

形状ベクタを指定して、任意の次元・要素数のブラケット構造を入力エリアに挿入する。

```ajisai
[ 3 ] FRAME           # → { } { } { }
[ 2 3 ] FRAME         # → { ( ) ( ) ( ) } { ( ) ( ) ( ) }
[ 2 2 3 ] FRAME       # → { ( [ ] [ ] [ ] ) ( [ ] [ ] [ ] ) } { ( [ ] [ ] [ ] ) ( [ ] [ ] [ ] ) }
```

- 形状ベクタは1〜3要素の正の整数
- 各次元の要素数は1〜100の範囲に制限

## 形状操作ワード

| ワード | 機能 |
|--------|------|
| `SHAPE` | 形状を取得 |
| `RANK` | 次元数を取得 |
| `RESHAPE` | 形状を変更 |
| `TRANSPOSE` | 転置 |
| `FILL` | 指定形状で値を埋める |

## 数値の内部表現

すべての数値は分数（Fraction）として内部的に扱われる：

```ajisai
5           # Fraction(5, 1)
3/4         # Fraction(3, 4)
0.5         # Fraction(1, 2)
```

これにより、浮動小数点演算の丸め誤差を回避する。

## 呼び出し深度制限

名前付きワード（カスタムワード）の呼び出し深度は最大3に制限されています。

### 制限の目的

1. **スタックオーバーフロー防止**: 無限再帰や深い再帰によるメモリ枯渇を防ぐ
2. **次元制限との一貫性**: 可視次元の制限と同じ値を使用
3. **コードの複雑さ抑制**: 深い呼び出しチェーンは可読性を損なう

### 例

```ajisai
# OK: 深度3（A -> B -> C）
[ ': HELPER' ] 'MAIN' DEF
[ ': INNER' ] 'HELPER' DEF
[ ': [ 2 ] *' ] 'INNER' DEF
[ 5 ] MAIN  # MAIN -> HELPER -> INNER（深度3）

# エラー: 深度4（A -> B -> C -> D）
[ ': B' ] 'A' DEF
[ ': C' ] 'B' DEF
[ ': D' ] 'C' DEF
[ ': [ 1 ]' ] 'D' DEF
A  # A -> B -> C -> D（深度4、超過）
# => Call depth limit (3) exceeded: A -> B -> C -> D
```

### 直接再帰

同じワードを自身から呼び出す直接再帰も深度制限の対象です：

```ajisai
# 再帰ワードの定義
[ ': DUP [ 0 ] <=
  : [ 1 ]
  : [ 1 ] - REC' ] 'REC' DEF

[ 5 ] REC  # REC -> REC -> REC -> REC（深度4で超過）
```

### 反復処理の推奨パターン

深い再帰の代わりに高階関数を使用することを推奨します：

```ajisai
# 深い再帰（深度制限に抵触する可能性）
[ ': DUP [ 1 ] <=
  : [ 1 ]
  : DUP [ 1 ] - FACT *' ] 'FACT' DEF

# 高階関数（深度制限なし）
[ ': [ 1 ] SWAP RANGE [ 1 ] * FOLD' ] 'FACT' DEF
```

### 注意事項

- 組み込みワード（`+`, `MAP`, `FOLD`等）は深度カウントに含まれません
- 高階関数内でのワード呼び出しは、その時点の深度からカウントされます
- 深度制限に達するとエラーが発生し、呼び出しスタックトレースが表示されます
