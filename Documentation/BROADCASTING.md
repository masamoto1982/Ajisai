# Ajisai ブロードキャスト規則

## 基本原則

NumPy/APLと同様のブロードキャスト規則を採用する。

ブロードキャストは、形状の異なるテンソル間で演算を行う際に、自動的に形状を調整する仕組みである。

## ブロードキャスト規則

### 1. 形状の比較は右から行う

```
形状 [2, 3] と [3] の比較:
  [2, 3]
     [3]
  ------
  [2, 3]  ← 結果の形状
```

### 2. 各次元は以下の場合に互換

- サイズが同じ
- どちらかが1

### 3. 足りない次元は左に1を追加して補う

```
[3] は [1, 3] として扱われる
[2, 3] + [3] → [2, 3] + [1, 3] → [2, 3]
```

### 4. サイズが1の次元は、必要に応じて拡張される

```
[2, 1] + [1, 3] → [2, 3]

説明:
- 軸0: 2 と 1 → 1が2に拡張される
- 軸1: 1 と 3 → 1が3に拡張される
```

## 例

### スカラーとベクタ

```ajisai
[ 5 ] [ 1 2 3 ] +
# [1] + [3] → [3]
# [ 5 ] が各要素に適用される
# → [ 6 7 8 ]
```

### ベクタと行列（行方向ブロードキャスト）

```ajisai
[ [ 1 2 3 ] [ 4 5 6 ] ] [ 10 20 30 ] +
# [2, 3] + [3] → [2, 3] + [1, 3] → [2, 3]
# [ 10 20 30 ] が各行に適用される
# → [ [ 11 22 33 ] [ 14 25 36 ] ]
```

### 列ベクタと行列（列方向ブロードキャスト）

```ajisai
[ [ 1 2 3 ] [ 4 5 6 ] ] [ [ 100 ] [ 200 ] ] +
# [2, 3] + [2, 1] → [2, 3]
# [ [ 100 ] [ 200 ] ] が各列に適用される
# → [ [ 101 102 103 ] [ 204 205 206 ] ]
```

### 1×1行列とN×M行列

```ajisai
[ [ 1 2 ] [ 3 4 ] ] [ [ 10 ] ] +
# [2, 2] + [1, 1] → [2, 2]
# [ [ 10 ] ] がすべての要素に適用される
# → [ [ 11 12 ] [ 13 14 ] ]
```

## エラーケース

以下の場合はブロードキャストできず、エラーとなる：

### 互換性のない形状

```ajisai
[ 1 2 3 ] [ 1 2 ] +
# [3] + [2] → エラー
# どちらも1でなく、サイズも異なる
```

```ajisai
[ [ 1 2 3 ] [ 4 5 6 ] ] [ [ 1 2 ] [ 3 4 ] ] +
# [2, 3] + [2, 2] → エラー
# 軸1: 3 と 2 は互換性がない
```

## 実装上の詳細

### 形状の計算アルゴリズム

```rust
fn broadcast_shapes(a: &[usize], b: &[usize]) -> Result<Vec<usize>> {
    let max_rank = a.len().max(b.len());
    let mut result = Vec::with_capacity(max_rank);

    // 右から比較
    for i in 0..max_rank {
        let a_dim = if i < a.len() { a[a.len() - 1 - i] } else { 1 };
        let b_dim = if i < b.len() { b[b.len() - 1 - i] } else { 1 };

        if a_dim == b_dim {
            result.push(a_dim);
        } else if a_dim == 1 {
            result.push(b_dim);
        } else if b_dim == 1 {
            result.push(a_dim);
        } else {
            return Err(format!(
                "Cannot broadcast shapes {:?} and {:?}",
                a, b
            ));
        }
    }

    result.reverse();
    Ok(result)
}
```

### インデックスのマッピング

ブロードキャスト時、各テンソルのインデックスは以下のように計算される：

```rust
fn broadcast_index(result_idx: &[usize], original_shape: &[usize]) -> Vec<usize> {
    let rank_diff = result_idx.len() - original_shape.len();
    let mut idx = Vec::with_capacity(original_shape.len());

    for (i, &dim) in original_shape.iter().enumerate() {
        let result_dim = result_idx[rank_diff + i];
        // サイズが1の次元は常にインデックス0
        idx.push(if dim == 1 { 0 } else { result_dim });
    }

    idx
}
```

## 高度な例

### 3次元テンソルのブロードキャスト

```ajisai
# 形状 [2, 3, 4] と [3, 1] のブロードキャスト
# [2, 3, 4] + [1, 3, 1] → [2, 3, 4]

# [3, 1] は [1, 3, 1] として扱われ、
# 各要素が軸0と軸2に沿って拡張される
```

### 外積の表現

外積は、形状を調整することでブロードキャストとして表現できる：

```ajisai
[ 1 2 3 ] [ 4 5 ] OUTER-AS-BROADCAST
# [3] を [3, 1] に、[2] を [1, 2] に reshape
# [3, 1] * [1, 2] → [3, 2]
```

ただし、Ajisaiでは専用の `OUTER` ワードを提供する。

## スタックモード（`..`）でのブロードキャスト

`..` モードでは、スタック全体を暗黙の最外殻次元として扱う：

```ajisai
1 2 3 .. 10 +
# スタック: [1, 2, 3]
# これを形状 [3] のベクタとして扱う
# [3] + [1] → [3]
# → スタック: [11, 12, 13]
```

この機能により、スタック全体への一括演算が可能になる。

## まとめ

ブロードキャスト規則により：

1. スカラーとテンソルの演算が自然に行える
2. 異なる形状のテンソル間の演算が可能
3. コードの簡潔性と表現力が向上

ただし、意図しない形状の組み合わせでエラーが発生する可能性があるため、形状を明示的に確認する習慣が重要である。
