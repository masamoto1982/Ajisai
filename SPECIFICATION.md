# Ajisai 言語仕様書

**バージョン:** v0.9.0
**ステータス:** 既存ドキュメント統合完了、対話を通じて段階的に拡充する

---

## 1. Ajisaiとは

Ajisaiは**Vector指向プログラミング言語**である。

植物学におけるアジサイの学名 *Hydrangea* は、ギリシア語の *hydor*（水）と *angos*（容器）に由来する。「水の容器」というこの語源が、Ajisaiのアーキテクチャの本質を表している。

- データは「水」: すべての計算データの本質は分数（Fraction）である
- 型は「波紋」: 表示時の解釈（DisplayHint）に過ぎず、演算には関与しない
- 形状は「容器」: 次元構造（shape）がデータの形を規定する
- NILは「泡」: 水の中に存在するが、水（分数）そのものではない
- CodeBlockは「水の注ぎ方」: 実行されて初めて水（分数）を生み出す生成手順

FORTHから継承したのは**後置記法**と**辞書システム**のみである。データ構造の中心はスタックではなく**Vector**であり、FORTH的なスタック操作（DUP, SWAP, ROT, OVER等）は存在しない。

---

## 2. コア特性

### 2.1 Vector指向

すべてのデータ構造の中心はVectorである。スタックは「暗黙の0次元Vector」として機能するが、言語の設計思想はスタック操作ではなく、Vectorに対する変換と写像に基づく。

### 2.2 統一分数アーキテクチャ（Unified Fraction Architecture）

すべての計算データは内部的に分数（Fraction）として表現される。型システムは存在しない。NIL（泡）とCodeBlock（水の注ぎ方）は分数ではなく、水系メタファーの中で独自の役割を持つメタ概念である。

#### 概念モデル

Ajisaiの設計思想を「水の容器」メタファーで表現する:

- **水（data）**: すべての計算データの本質は分数（Fraction）である。整数も小数も文字も、内部的には分数として存在する
- **波紋（display_hint）**: 表示時の解釈に過ぎず、演算には一切関与しない
- **容器（shape）**: 次元構造がデータの形を規定する。形状は再帰的なネスト構造から動的に導出される
- **泡（NIL）**: 水の中に存在するが、水そのものではない。演算に触れても水にならず、泡のまま浮き上がる（NIL伝播）
- **水の注ぎ方（CodeBlock）**: 遅延されたコード。実行されて初めて水（分数）を生み出す生成手順であり、水そのものではない

| 概念 | 役割 | 演算への影響 |
|------|------|-------------|
| 水（data） | 実際のデータ（分数） | 唯一の計算対象 |
| 波紋（display_hint） | 表示形式のヒント | なし（表示時のみ参照） |
| 容器（shape） | 多次元配列の形状 | RESHAPE等の形状操作のみ |
| 泡（NIL） | 値の不在 | NIL伝播（演算を通過して浮上） |
| 水の注ぎ方（CodeBlock） | 遅延されたコード | EXEC/MAP等で実行時に水を生成 |

#### 実装構造

```rust
pub struct Value {
    pub data: ValueData,            // 水（再帰的データ構造）
    pub display_hint: DisplayHint,  // 波紋（表示時の解釈）
    pub audio_hint: Option<AudioHint>, // 音楽DSL用メタデータ
}

pub enum ValueData {
    Scalar(Fraction),       // 水: 単一の分数（スカラー値）
    Vector(Vec<Value>),     // 容器の集合: Valueの配列（再帰的にネスト可能）
    Nil,                    // 泡: 値の不在（水の中に在るが水ではない）
    CodeBlock(Vec<Token>),  // 水の注ぎ方: 遅延評価されるコード（分数ではない）
}
```

`ValueData` は再帰的定義であり、`Vector(Vec<Value>)` がValueを含むことで任意深度のネスト構造を自然に表現する。形状（shape）は明示的なフィールドではなく、ネスト構造から動的に計算される。

`CodeBlock` はコードブロック（`: ... ;`）をスタック上の第一級値として保持するためのバリアントであり、DEFによるワード定義やMAP/FILTER/FOLD/TIMESへの引数として使用される。

#### 内部表現

| ユーザーから見える姿 | 内部表現 | 説明 |
|---------------------|---------|------|
| `42` | `Scalar(42/1)` | 整数は分数 |
| `1/3` | `Scalar(1/3)` | 分数リテラル |
| `0.5` | `Scalar(1/2)` | 小数は分数に変換 |
| `TRUE` | `Scalar(1/1)` + Boolean hint | 1が真、0が偽 |
| `'A'` | `Scalar(65/1)` + String hint | 文字コード（Unicode） |
| `'Hello'` | `Vector([Scalar(72/1), ...])` + String hint | 文字コードの配列 |
| `NIL` | `Nil` | 値の不在（独立した表現） |
| `[ ]` | --- | エラー（空ブラケットは禁止） |
| `''` | `Nil` + String hint | 空文字列はNIL（String hintを保持） |

#### Fraction型

```rust
pub struct Fraction {
    pub numerator: BigInt,   // 分子（任意精度）
    pub denominator: BigInt, // 分母（任意精度）
}
```

- 任意精度: `num-bigint` クレートによる無制限精度
- 自動簡約: GCD計算により常に最簡形を維持
- 符号の正規化: 分母は常に正の整数。負の分数は分子で符号を表現する（例: `-1/3`）。リテラル `1/-3` は分数として解釈されない
- サポートする数値形式: 整数（`42`）、小数（`1.5`）、分数（`1/3`）、指数（`1e10`）

#### DisplayHint

`DisplayHint` は表示専用の情報であり、演算には一切使用しない。

```rust
pub enum DisplayHint {
    Auto,      // 自動判定
    Number,    // 数値として表示
    String,    // 文字列として表示
    Boolean,   // 真偽値として表示
    DateTime,  // 日時として表示
    Nil,       // NILとして表示
}
```

重要な原則:

1. 演算は `data` のみを参照する。`display_hint` は無視される
2. 表示時のみ `display_hint` を参照し、フォーマットを決定する
3. 形式変換ワード（STR, NUM, BOOL等）は `display_hint` を変更する。`data` は必要に応じて変換される

### 2.3 構造的制限

Ajisaiは認知的負荷を制御するために、以下の制限を設けている。

| 制限 | 値 | 説明 |
|------|-----|------|
| ネスト次元 | 10 | 括弧3種 × 3サイクル + スタック（詳細は2.4節） |
| 呼び出し深度 | 3 | `A -> B -> C` まで |

呼び出し深度制限はAjisaiの設計の核心であり、緩和の対象ではない。

#### 呼び出し深度制限

名前付きワード（カスタムワード）の呼び出し深度は最大3に制限される。

```ajisai
# 深度3: 正常動作
# MAIN -> HELPER -> INNER
: INNER ; 'HELPER' DEF
: HELPER ; 'MAIN' DEF

# 深度4: エラー
# A -> B -> C -> D
# -> Call depth limit (3) exceeded: A -> B -> C -> D
```

制限の対象:

- カスタムワード同士の呼び出しチェーンのみカウントされる
- 組み込みワード（`+`, `MAP`, `FOLD`等）は深度カウントに含まれない
- 高階関数内でのワード呼び出しは、その時点の深度からカウントされる
- 直接再帰も深度制限の対象となる

深い再帰の代わりに高階関数（MAP, FILTER, FOLD）の使用を推奨する。

### 2.4 次元モデル

Ajisaiのネスト表現には `[]` `{}` `()` の3種類の括弧を使用する。
GUIのスタックエリアは暗黙的に `[]`（第1次元）に相当し、そこから括弧が以下のサイクルで対応する:

| 次元 | 括弧 | 備考 |
|------|------|------|
| 1次元 | `[]` | スタック最外殻（暗黙） |
| 2次元 | `{}` | |
| 3次元 | `()` | |
| 4次元 | `[]` | |
| 5次元 | `{}` | |
| 6次元 | `()` | |
| 7次元 | `[]` | |
| 8次元 | `{}` | |
| 9次元 | `()` | |
| 10次元 | `[]` | 上限 |

3種の括弧が3サイクルして `[]` に戻ったところを上限とする。
これは「両手の指の数（10）」という人間の認知的上限と一致し、かつ括弧システムの構造的な区切りとも整合する。

**10次元を超えるネストはエラーとする。** エラー時はスタックを変更しない。

```
Nesting depth limit exceeded: Ajisai supports up to 10 dimensions.
Nesting depth 11 exceeds the limit.
```

#### 括弧表示規則

入力時は `[]`, `{}`, `()` のいずれも同等に扱われる。表示時に深さに応じた括弧に自動変換される。

```ajisai
# 入力 -> 表示
[ 1 2 3 ]                          # -> { 1 2 3 }
[ [ 1 2 ] [ 3 4 ] ]                # -> { ( 1 2 ) ( 3 4 ) }
[ [ [ 1 2 ] [ 3 4 ] ] [ [ 5 6 ] [ 7 8 ] ] ]
                                    # -> { ( [ 1 2 ] [ 3 4 ] ) ( [ 5 6 ] [ 7 8 ] ) }
```

複数のVectorがスタック上にある場合、各Vectorは独立して `{}` から始まる:

```ajisai
[ 1 2 ] [ 3 4 ]                    # -> { 1 2 }  { 3 4 }
```

#### 形状（Shape）

各次元のサイズを表すVectorである。

```ajisai
{ 1 2 3 }                          # 形状: { 3 }
{ ( 1 2 3 ) ( 4 5 6 ) }            # 形状: { 2 3 }
```

#### 矩形制約

同一次元内の要素は同じ形状でなければならない。

```ajisai
{ ( 1 2 ) ( 3 4 ) }                # 正当: 各行が長さ2
{ ( 1 2 ) ( 3 4 5 ) }              # エラー: 行の長さが不一致
```

### 2.5 ブロードキャスト

NumPy/APL と同様のブロードキャスト規則を採用する。形状の異なるテンソル間の演算を自動的な形状調整により可能にする。

#### 規則

1. **形状の比較は右から行う**
2. **各次元は以下の場合に互換**: サイズが同じ、またはどちらかが1
3. **足りない次元は左に1を追加して補う**
4. **サイズが1の次元は、必要に応じて拡張される**

```
形状 [2, 3] と [3] の比較:
  [2, 3]
     [3]    <- [1, 3] として扱う
  ------
  [2, 3]   <- 結果の形状
```

#### 具体例

```ajisai
# スカラーとVector
[ 5 ] [ 1 2 3 ] +                  # -> [ 6 7 8 ]

# Vectorと行列（行方向ブロードキャスト）
[ [ 1 2 3 ] [ 4 5 6 ] ] [ 10 20 30 ] +
                                    # -> [ [ 11 22 33 ] [ 14 25 36 ] ]

# 列Vectorと行列（列方向ブロードキャスト）
[ [ 1 2 3 ] [ 4 5 6 ] ] [ [ 100 ] [ 200 ] ] +
                                    # -> [ [ 101 102 103 ] [ 204 205 206 ] ]
```

#### エラーケース

互換性のない形状ではブロードキャストできずエラーとなる:

```ajisai
[ 1 2 3 ] [ 1 2 ] +                # エラー: [3] と [2] は互換性なし
```

### 2.6 「変化なしはエラー」原則

Ajisaiでは、ワードの実行結果が入力と同一である場合、それをエラーとして扱う。「何も変わらない操作」は意味のない操作であり、プログラマの意図しない動作を早期に検出するための設計原則である。

この原則が適用される場面:

| カテゴリ | 具体例 | 理由 |
|---------|--------|------|
| 構造操作 | `[ 1 ] REVERSE` | 1要素では反転しても変化なし |
| 構造操作 | `[ 1 2 1 ] REVERSE` | 回文は反転しても変化なし |
| ソート | `[ 1 2 3 ] SORT` | 既にソート済み |
| ソート | `[ 1 1 1 ] SORT` | 全要素が同一 |
| 形式変換 | `'hello' STR` | 既に文字列形式 |
| 形式変換 | `123 NUM` | 既に数値形式 |
| 形式変換 | `TRUE BOOL` | 既に真偽値形式 |
| 算術 | `[ 1 2 3 ] [ 0 ] +` | 0の加算は変化なし |
| 算術 | `[ 1 2 3 ] [ 1 ] *` | 1の乗算は変化なし |
| 文字列 | `[ '' ] CHARS` | 空文字列の分解は変化なし |

この原則は「プログラマを信頼する」というFORTH精神の継承ではなく、「意味のない操作を禁止する」というAjisai独自の設計判断である。

### 2.7 NIL

NILはAjisaiにおける「値の不在」を表すセンチネル値である。

#### 内部表現

```
data: ValueData::Nil      （独立した表現）
display_hint: Nil
```

NILは `ValueData::Nil` として独立したバリアントで表現される。`Fraction(0/0)` はNIL判定の互換メソッドとして存在するが、主表現ではない。

#### 空ブラケットの禁止

空ブラケット `[ ]` はエラーとなる。NILが必要な場合は `NIL` キーワードを使用する。

```ajisai
[ ]                                 # エラー: Empty vector is not allowed
NIL                                 # NIL（センチネル値 0/0）
[ 1 NIL 3 ]                        # NILを要素として持つVector
```

#### NILに対する操作

| 操作 | 結果 | 説明 |
|------|------|------|
| `NIL LENGTH` | `[ 0 ]` | 長さ0 |
| `NIL 'WORD' MAP` | `NIL` | NILをMAPしてもNIL |
| `NIL [ 42 ] : + ; FOLD` | `[ 42 ]` | 初期値がそのまま返る |
| `NIL => [ 0 ]` | `[ 0 ]` | Nil Coalescingで代替値 |
| `[ 42 ] => [ 0 ]` | `[ 42 ]` | 非NILはそのまま |

#### FILTERとNIL

FILTERで該当要素がない場合はNILを返す。Nil Coalescing演算子 `=>` と組み合わせてデフォルト値を設定できる。

```ajisai
[ 1 2 3 ] : [ 10 ] < NOT ; FILTER  # -> NIL（該当なし）
[ 1 2 3 ] : [ 10 ] < NOT ; FILTER => [ 0 ]
                                    # -> [ 0 ]（デフォルト値）
```

### 2.8 コメント

`#` 以降は行末までコメントとして扱われる。

```ajisai
[ 1 2 3 ] + # これはコメント
123#数値の直後でもコメントになる   # -> [ 123 ]
1/3#分数の後のコメント             # -> [ 1/3 ]
'#文字列内は保護される'            # -> '#文字列内は保護される'
```

`#` はトークン境界として機能するため、数値やリテラルの読み取りは `#` の直前で停止する。文字列リテラル内の `#` はコメントとして解釈されない。

---

## 3. 操作修飾子

### 3.1 操作対象モード

| 修飾子 | 名称 | 動作 |
|--------|------|------|
| `.` | スタックトップモード | スタック最上位の1要素に対して操作を適用（デフォルト） |
| `..` | スタック全体モード | スタック全体（0次元Vector）に対して操作を適用 |

ワード実行後、自動的にスタックトップモード（`.`）にリセットされる。

### 3.2 消費モード

| 修飾子 | 名称 | 動作 |
|--------|------|------|
| `,` | 消費モード | オペランドをスタックから消費する（デフォルト） |
| `,,` | 保持モード | オペランドをスタックに残したまま結果を追加する |

ワード実行後、自動的に消費モード（`,`）にリセットされる。

修飾子は順序非依存である: `.. ,,` と `,, ..` は同じ動作をする。

### 3.3 デフォルト消費原則

**すべてのワードはデフォルトで対象（オペランド）を消費する。** これはAjisaiにおける消費性の均一原則である。

元の値を保持したい場合は、保持モード `,,` で明示的に指定する。ワードごとに消費性が異なるという暗黙の例外は設けない。

```ajisai
# GET: 対象Vectorと引数Vectorを消費し、取得した要素を返す
[ 10 20 30 ] [ 0 ] GET        # -> [ 10 ]
[ 10 20 30 ] [ 0 ] ,, GET     # -> [ 10 20 30 ] [ 0 ] [ 10 ]  （保持モード）

# LENGTH: 対象Vectorを消費し、要素数を返す
[ 1 2 3 4 5 ] LENGTH           # -> [ 5 ]
[ 1 2 3 4 5 ] ,, LENGTH       # -> [ 1 2 3 4 5 ] [ 5 ]  （保持モード）

# 算術: 両オペランドを消費し、結果を返す
[ 1 2 3 ] [ 10 ] +            # -> [ 11 12 13 ]
[ 1 2 3 ] [ 10 ] ,, +         # -> [ 1 2 3 ] [ 10 ] [ 11 12 13 ]  （保持モード）
```

この原則により、プログラマは `,,` の有無だけで消費性を判断できる。ワードごとの暗記は不要になる。

#### スタック全体モード（`..`）での消費性

`..` モードでは操作対象が「スタック全体」になる。デフォルト消費原則はここでも同様に適用される。

```ajisai
# GET: スタック全体を消費し、取得した要素を返す
a b c [ 1 ] .. GET            # -> [ b ]
a b c [ 1 ] ,, .. GET         # -> a b c [ b ]  （保持モード）

# LENGTH: スタック全体を消費し、要素数を返す
1 2 3 4 5 .. LENGTH            # -> [ 5 ]
1 2 3 4 5 ,, .. LENGTH         # -> 1 2 3 4 5 [ 5 ]  （保持モード）

# REVERSE: スタック全体を消費し、反転結果を再配置する
a b c .. REVERSE               # -> c b a
```

#### 保持モード（`,,`）の範囲

`,,` はワードが消費するすべてのオペランドを保持する。対象Vectorのみ、あるいは引数Vectorのみを選択的に保持することはできない。

```ajisai
# TAKE: 対象Vectorと引数Vectorの両方を消費/保持する
[ 1 2 3 4 5 ] [ 3 ] TAKE      # -> [ 1 2 3 ]                      （両方消費）
[ 1 2 3 4 5 ] [ 3 ] ,, TAKE   # -> [ 1 2 3 4 5 ] [ 3 ] [ 1 2 3 ]  （両方保持）

# INSERT: 同上
[ 1 3 ] [ 1 2 ] INSERT         # -> [ 1 2 3 ]                       （両方消費）
[ 1 3 ] [ 1 2 ] ,, INSERT      # -> [ 1 3 ] [ 1 2 ] [ 1 2 3 ]       （両方保持）
```

### 3.4 セーフモード

| 修飾子 | 名称 | 動作 |
|--------|------|------|
| `~` | セーフモード | ワード実行中にエラーが発生した場合、エラーを抑制しNILを返す |

セーフモードはワードの実行を「失敗してもよい」ものとして扱う。エラーが発生した場合、スタックはワード実行前の状態に復元され、結果としてNILがプッシュされる。エラーが発生しなかった場合は通常通りの結果を返す。

```ajisai
# 通常: エラーで停止
[ 1 2 3 ] [ 10 ] GET              # エラー: Index 10 out of bounds

# セーフモード: エラー時にNILを返す
[ 1 2 3 ] [ 10 ] ~ GET            # -> NIL

# => と組み合わせてデフォルト値を提供
[ 1 2 3 ] [ 10 ] ~ GET => [ 0 ]   # -> [ 0 ]

# 正常時はそのまま結果を返す
[ 1 2 3 ] [ 1 ] ~ GET             # -> [ 20 ]
```

ワード実行後、自動的にセーフモードは解除される（他の修飾子と同様）。

#### 他の修飾子との組み合わせ

`~` は `.`/`..` および `,`/`,,` と組み合わせ可能である。修飾子は順序非依存。

```ajisai
# セーフ + 保持 + スタック全体
a b c [ 10 ] ~ ,, .. GET          # -> a b c NIL（エラー時）
```

#### 適用対象

`~` はすべての組み込みワードに対して使用可能である。ただし以下のワードには適用しても意味がない（エラーを発生させないため）。

- 定数: `TRUE`, `FALSE`, `NIL`
- 修飾子自身: `.`, `..`, `,`, `,,`, `!`, `==`
- 制御フロー: `:`, `;`（構文要素のため修飾子が適用されない）

#### 設計上の注意

- `~` は「エラーを握りつぶす」のではなく「エラーをNILに変換する」ものである。これはAjisaiのNIL安全性モデル（セクション7）と一貫している。
- 「変化なしはエラー」原則も `~` の対象となる。例: `[ 1 ] ~ REVERSE` は NIL を返す（変化なしエラーがNILに変換される）。
- `~` を使用するかどうかはプログラマの明示的な判断であり、Ajisaiの「trust the programmer」精神を維持する。

---

## 4. 制御構造

### 4.1 コードブロック

`: コード ;` でコードブロック（遅延評価されるコード）を定義する。DEFでのワード定義やMAP/FILTER/FOLDの引数に使用する。

### 4.2 シェブロン分岐（ガード）

`>>` で条件、`>>` でアクション、`>>>` でデフォルトアクションを定義する多分岐構造。

```ajisai
:
  >> [ 0 ] <
  >> [ -1 ]
  >> [ 0 ] =
  >> [ 0 ]
  >>> [ 1 ]
; 'SIGN' DEF
```

### 4.3 パイプライン演算子

`==` はデータフローを視覚的に明示するためのno-opマーカーである。

```ajisai
[ 1 2 3 4 5 ]
  == : [ 2 ] * ; MAP
  == : [ 5 ] < NOT ; FILTER
  == [ 0 ] : + ; FOLD
```

### 4.4 Nil Coalescing演算子

`=>` は値がNILの場合に代替値を返す。

```ajisai
NIL => [ 0 ]       # -> [ 0 ]
[ 42 ] => [ 0 ]    # -> [ 42 ]
```

---

## 5. ワードシグネチャ型

すべてのデータ操作ワードは、以下の3つのシグネチャ型のいずれかに属する。シグネチャ型が操作修飾子（`.`/`..`、`,`/`,,`）の挙動を決定する。個々のワードごとに修飾子の挙動を暗記する必要はない。

```
Map型（写像）    — 各要素に独立して変換を射す
Form型（構造）   — 集合の構造に作用する
Fold型（還元）   — 複数の値を一つに畳み込む
```

### 5.1 Map型（写像）

個々の値を独立に変換する。入力と出力の要素数は同じ。

| 修飾子 | 動作 |
|--------|------|
| `. ,` | スタックトップを消費し、変換結果をプッシュ |
| `. ,,` | スタックトップを保持し、変換結果を追加 |
| `.. ,` | スタック上の各要素を消費し、各変換結果をプッシュ |
| `.. ,,` | スタック上の各要素を保持し、各変換結果を追加 |

```ajisai
[ 1 ] STR                         # -> '1'
[ 1 ] ,, STR                      # -> [ 1 ] '1'
[ 1 ] [ 2 ] [ 3 ] .. STR          # -> '1' '2' '3'
[ 1 ] [ 2 ] [ 3 ] ,, .. STR       # -> [ 1 ] [ 2 ] [ 3 ] '1' '2' '3'
```

### 5.2 Form型（構造）

集合の構造に対して操作する。`..` ではスタック全体を一つの集合として扱う。

| 修飾子 | 動作 |
|--------|------|
| `. ,` | スタックトップの集合を消費し、操作結果をプッシュ |
| `. ,,` | スタックトップの集合を保持し、操作結果を追加 |
| `.. ,` | スタック全体を一つの集合として消費し、操作結果をプッシュ |
| `.. ,,` | スタック全体を保持し、操作結果を追加 |

```ajisai
[ 3 1 2 ] SORT                    # -> [ 1 2 3 ]
[ 3 1 2 ] ,, SORT                 # -> [ 3 1 2 ] [ 1 2 3 ]
[ 3 ] [ 1 ] [ 2 ] .. SORT         # -> [ 1 ] [ 2 ] [ 3 ]
[ 3 ] [ 1 ] [ 2 ] ,, .. SORT      # -> [ 3 ] [ 1 ] [ 2 ] [ 1 ] [ 2 ] [ 3 ]
```

### 5.3 Fold型（還元）

2つの値を1つに結合する。`..` ではN個の値を左から順に畳み込む。

| 修飾子 | 動作 |
|--------|------|
| `. ,` | 上位2つのオペランドを消費し、結果をプッシュ |
| `. ,,` | 上位2つのオペランドを保持し、結果を追加 |
| `.. ,` | N個のオペランドを消費し、左から順に畳み込んだ結果をプッシュ |
| `.. ,,` | N個のオペランドを保持し、畳み込み結果を追加 |

```ajisai
[ 3 ] [ 4 ] +                     # -> [ 7 ]
[ 3 ] [ 4 ] ,, +                  # -> [ 3 ] [ 4 ] [ 7 ]
[ 1 ] [ 2 ] [ 3 ] [ 3 ] .. +      # -> [ 6 ]
[ 1 ] [ 2 ] [ 3 ] [ 3 ] ,, .. +   # -> [ 1 ] [ 2 ] [ 3 ] [ 6 ]
```

### 5.4 シグネチャ型を持たないワード

以下のワードはデータ操作ワードではないため、シグネチャ型を持たない。

| 分類 | ワード |
|------|--------|
| 定数 | `TRUE` `FALSE` `NIL` |
| 生成 | `NOW` `CSPRNG` `DATETIME` `TIMESTAMP` |
| 修飾子 | `.` `..` `,` `,,` `~` `!` `==` |
| 制御フロー | `:` `;` `>>` `>>>` `=>` `WAIT` `TIMES` |
| ワード管理 | `DEF` `DEL` `?` |
| 入力支援 | `'` `FRAME` |
| スタック操作 | `COLLECT` |
| メタプログラミング | `EXEC` `EVAL` `HASH` |

#### TIMES

コードブロックまたはカスタムワード名をN回繰り返し実行する。

```ajisai
# コードブロック構文
[ 0 ] : [ 1 ] + ; [ 5 ] TIMES     # -> [ 5 ]（0に1を5回加算）

# ワード名構文
: [ 2 ] * ; 'DOUBLE' DEF
[ 1 ] 'DOUBLE' [ 4 ] TIMES         # -> [ 16 ]（1を4回2倍）
```

- コードブロック（`: ... ;`）とワード名（文字列）の両方を受け付ける
- 組み込みワードには使用不可（カスタムワードのみ）
- TIMES内のループ中は「変化なしはエラー」原則が無効化される（同じ操作の繰り返しは意図的であるため）

#### EXEC

ベクタをコードとして解釈し実行する（Vector Duality）。

```ajisai
# StackTopモード（デフォルト）: スタックトップのベクタをコードとして実行
[ [ 2 ] [ 3 ] * ] EXEC             # -> [ 6 ]

# Stackモード: スタック全体をベクタとみなしてコードとして実行
[ 1 ] [ 1 ] '+' .. EXEC            # -> [ 2 ]
```

- ベクタ内の要素はコードとして再解釈される: 数値はリテラル、文字列はワード名、ネストベクタはベクタリテラル
- `.`/`..` モードに対応

#### EVAL

文字列をパースしてコードとして実行する。

```ajisai
# StackTopモード（デフォルト）: スタックトップの文字列をパースして実行
'[ 2 ] [ 3 ] *' EVAL               # -> [ 6 ]

# Stackモード: スタック全体を文字コード列として結合し、パースして実行
[ 49 ] [ 32 ] [ 50 ] [ 32 ] [ 43 ] .. EVAL  # -> 3（"1 2 +" を実行）
```

- `.`/`..` モードに対応
- カスタムワードも文字列内で使用可能

#### COLLECT

スタックからN個の要素を収集してベクタを作成する。

```ajisai
1 2 3 3 COLLECT                     # -> [ 1 2 3 ]
[ 1 2 ] [ 3 4 ] 2 COLLECT          # -> [ [ 1 2 ] [ 3 4 ] ]（フラット化しない）
```

- `[ ]` リテラル構文ではスタック上の計算結果を動的にベクタにまとめることができないため、この操作は組み込みワードの組み合わせでは再現できない
- 引数の整数値はベクタに包まず、スカラーとしてスタックに直接置く（`3 COLLECT` であり `[ 3 ] COLLECT` ではない）
- CONCATとの違い: COLLECTは要素をそのまま保持し、CONCATはフラット化して結合する

#### !（強制フラグ）

被依存カスタムワードのDEL/DEFを許可する。

```ajisai
: [ 2 ] * ; 'DOUBLE' DEF
: DOUBLE DOUBLE ; 'QUAD' DEF

# DOUBLEはQUADから参照されているため通常は削除/再定義できない
'DOUBLE' DEL                        # エラー: DOUBLE is referenced by: QUAD

# ! を付けると強制的に削除/再定義が可能（警告メッセージが出力される）
! 'DOUBLE' DEL                      # 成功（Warning出力あり）
! : [ 3 ] * ; 'DOUBLE' DEF          # 成功（Warning出力あり）
```

- 組み込みワードに対しては `!` があっても削除・上書き不可（BuiltinProtectionエラー）
- `!` はDELまたはDEFの直前でのみ有効。他のワードを実行するとフラグがリセットされる

---

## 6. ワード一覧

### 6.1 組み込みワードの分類原則

Ajisaiでは、**組み込みワードの組み合わせでは再現できない機能を提供するワード**を組み込みワードとして分類する。組み込みワードは削除・上書きできない。

この原則により、音楽DSLワード（`PLAY`, `SEQ`, `SIM`等）もコア言語ワード（`GET`, `MAP`, `+`等）と同様に組み込みワードとして扱われる。これらはRustネイティブ実装でのみ実現可能な機能（オーディオ出力の発行、内部状態レジスタの操作等）を提供するためである。

一方、組み込みワードの組み合わせで定義できるワード（例: 純正律音階 `C4 [ 9/8 ] *` で定義する `D4`）はカスタムワードである。

### 6.2 ワード一覧

以下に機能カテゴリとシグネチャ型の二軸で分類する。

| 機能カテゴリ | ワード | シグネチャ |
|-------------|--------|:----------:|
| 位置操作（0オリジン） | `GET` | Form |
| | `INSERT` | Form |
| | `REPLACE` | Form |
| | `REMOVE` | Form |
| 量操作 | `LENGTH` | Form |
| | `TAKE` | Form |
| Vector操作 | `SPLIT` | Form |
| | `CONCAT` | Form |
| | `REVERSE` | Form |
| | `RANGE` | Form |
| | `REORDER` | Form |
| | `COLLECT` | --- |
| | `SORT` | Form |
| 文字列操作 | `CHARS` | Map |
| | `JOIN` | Map |
| 形式変換 | `NUM` | Map |
| | `STR` | Map |
| | `BOOL` | Map |
| | `CHR` | Map |
| 算術 | `FLOOR` `CEIL` `ROUND` | Map |
| | `+` `-` `*` `/` `MOD` | Fold |
| 比較 | `=` `<` `<=` | Fold |
| 論理 | `NOT` | Map |
| | `AND` `OR` | Fold |
| 高階関数 | `MAP` `FILTER` `FOLD` | Form |
| 制御フロー | `TIMES` | --- |
| | `WAIT` | --- |
| メタプログラミング | `EXEC` | --- |
| | `EVAL` | --- |
| | `HASH` | --- |
| 生成 | `CSPRNG` | --- |
| 日時 | `NOW` | --- |
| | `DATETIME` | --- |
| | `TIMESTAMP` | --- |
| 形状操作 | `SHAPE` `RANK` | Map |
| | `RESHAPE` `TRANSPOSE` `FILL` | Form |
| 入出力 | `PRINT` | Map |
| | `INPUT` | --- |
| | `OUTPUT` | --- |
| JSON連携 | `PARSE` | Map |
| | `STRINGIFY` | Map |
| | `JSON-GET` | Form |
| | `JSON-KEYS` | Form |
| | `JSON-SET` | Form |
| 音楽DSL | `SEQ` `SIM` `PLAY` `CHORD` | --- |
| | `SLOT` | --- |
| | `GAIN` `GAIN-RESET` `PAN` `PAN-RESET` `FX-RESET` | --- |
| | `ADSR` | --- |
| | `SINE` `SQUARE` `SAW` `TRI` | --- |

**注記:** `>` と `>=` は提供しない。`<` と `<=` のみを使用する（オペランドの順序で代替可能）。

### 6.3 カスタムワード

`: コード ; '名前' DEF` でユーザーが定義するワード。ワード名は自動的に大文字に変換される。呼び出し深度制限（最大3）の対象となる。

### 6.4 GUI辞書表示

GUIの辞書エリアでは、組み込みワードとカスタムワードを別々のセクションに表示する。

**表示順序:**
- 記号ワード（先頭文字がアルファベットでないもの）を先に、記号の文字コード順で表示
- アルファベットワードを後に、アルファベット昇順で表示

**ソート規則の例:**
```
記号: ! ' * + , ,, - . .. / : ; < <= = == => >> >>> ?
英字: ADSR AND BOOL CEIL CHARS ... WAIT
```

組み込みワードのカテゴリグルーピングは行わない。カスタムワードも同じソート規則に従う。

各ワードボタンにはホバー時にdescription（組み込みワード）またはワード定義（カスタムワード）が表示される。

#### 6.4.1 ワードボタンの色エンコーディング

ワードボタンは**2つの独立した色チャンネル**で情報を伝える。

**チャンネル1: 文字色・枠線色（ワードの性質）**

これは既存の仕様であり、変更しない。

| 分類 | 文字色・枠線色 | 意味 |
|------|---------------|------|
| 組み込みワード | `--color-builtin` | 上書き・削除不可 |
| 被依存カスタムワード | `--color-dependency` | 他のカスタムワードから参照されている |
| 非依存カスタムワード | `--color-non-dependency` | 他のカスタムワードから参照されていない |

**チャンネル2: 背景色（シグネチャ型）**

| シグネチャ型 | CSS変数名 | 意味 |
|-------------|-----------|------|
| Map型（写像） | `--color-signature-map` | 各要素に独立して変換を射す |
| Form型（構造） | `--color-signature-form` | 集合の構造に作用する |
| Fold型（還元） | `--color-signature-fold` | 複数の値を一つに畳み込む |
| None（型なし） | なし（白背景を維持） | シグネチャ型を持たないワード |

**色選定の制約:**

- 背景色は十分に薄い色（高明度・低彩度）とし、チャンネル1の文字色（`#E65100`, `#E69500`, `#009B68`）とのコントラスト比がWCAG AA（4.5:1）以上を維持すること
- 3つのシグネチャ型は色相で区別しつつ、明度差もつけることで色覚多様性に配慮すること
- None型はシグネチャ型を持たないことを示すため、現状の白背景（`#fff`）を維持する

**カスタムワードへの適用:**

カスタムワードはシグネチャ型を持たないため、常にNone型（白背景）として表示する。

#### 6.4.2 各ワードのシグネチャ型分類

以下の分類はセクション6.2のワード一覧に既に記載されているが、GUI表示の根拠として改めて明示する。

```
Map型:  CHARS, JOIN, NUM, STR, BOOL, CHR, FLOOR, CEIL, ROUND, NOT, SHAPE, RANK, PRINT,
        PARSE, STRINGIFY
Form型: GET, INSERT, REPLACE, REMOVE, LENGTH, TAKE, SPLIT, CONCAT, REVERSE, RANGE,
        REORDER, SORT, MAP, FILTER, FOLD, RESHAPE, TRANSPOSE, FILL,
        JSON-GET, JSON-KEYS, JSON-SET
Fold型: +, -, *, /, MOD, =, <, <=, AND, OR
None:   上記以外の全ワード（定数、修飾子、制御フロー、入力支援、メタ、スタック操作、
        生成、日時、音楽DSL、入出力 — COLLECT, TIMES, WAIT, EXEC, EVAL, HASH,
        CSPRNG, NOW, DATETIME, TIMESTAMP, INPUT, OUTPUT 等）
```

---

## 7. NIL安全性と三値論理

Ajisaiは Kleene の強三値論理に基づくNIL伝播モデルを採用する。基本原則は**「結果が論理的に確定できるならNILを吸収し、できないなら伝播する」**である。

### 7.1 シグネチャ型別のNIL挙動

| シグネチャ型 | NIL挙動 | 根拠 |
|---|---|---|
| Map型 | NIL伝播 | 不明な値の変換は不明 |
| Form型 | NIL = 空集合 | 値の不在 = 空の集合 |
| Fold型（算術・比較） | NIL伝播 | 不明との演算は不明 |
| Fold型（論理） | Kleene三値規則 | 確定可能なら吸収 |

### 7.2 Map型のNIL伝播

不明な値に変換を射しても不明である。

```ajisai
NIL STR                            # -> NIL
NIL FLOOR                          # -> NIL
NIL CHARS                          # -> NIL
NIL NOT                            # -> NIL
```

### 7.3 Form型のNIL処理

NILは「値の不在」であり、空の集合として扱う。

```ajisai
NIL LENGTH                         # -> [ 0 ]
NIL SORT                           # -> NIL
NIL REVERSE                        # -> NIL
NIL 'WORD' MAP                     # -> NIL
NIL 'WORD' FILTER                  # -> NIL
NIL [ 42 ] : + ; FOLD              # -> [ 42 ]（初期値がそのまま返る）
```

### 7.4 Fold型（算術・比較）のNIL伝播

不明な値との演算結果は不明である。

```ajisai
NIL [ 1 ] +                       # -> NIL
NIL [ 1 ] *                       # -> NIL
NIL [ 1 ] =                       # -> NIL
NIL [ 1 ] <                       # -> NIL
```

### 7.5 Fold型（論理）のKleene三値規則

論理演算では、一方のオペランドだけで結果が確定する場合、NILは吸収される。

#### AND 真理値表

| 左 \ 右 | TRUE | FALSE | NIL |
|---------|------|-------|-----|
| **TRUE** | TRUE | FALSE | NIL |
| **FALSE** | FALSE | FALSE | FALSE |
| **NIL** | NIL | FALSE | NIL |

#### OR 真理値表

| 左 \ 右 | TRUE | FALSE | NIL |
|---------|------|-------|-----|
| **TRUE** | TRUE | TRUE | TRUE |
| **FALSE** | TRUE | FALSE | NIL |
| **NIL** | TRUE | NIL | NIL |

```ajisai
FALSE NIL AND                      # -> FALSE  （FALSE AND x = 常にFALSE）
TRUE NIL AND                       # -> NIL    （不確定）
TRUE NIL OR                        # -> TRUE   （TRUE OR x = 常にTRUE）
FALSE NIL OR                       # -> NIL    （不確定）
NIL NOT                            # -> NIL    （不明の否定は不明）
```

### 7.6 Nil Coalescing演算子

`=>` はNILに対する明示的な代替値を提供する。パイプラインの末端でNILを安全に処理するための標準的な手段である。

```ajisai
NIL => [ 0 ]                      # -> [ 0 ]（NILの場合は代替値）
[ 42 ] => [ 0 ]                   # -> [ 42 ]（非NILはそのまま）

# パイプラインでの使用例
[ 1 2 3 ]
  == : [ 10 ] < NOT ; FILTER
  == => [ 0 ]                      # FILTERがNILを返した場合の安全策
```

### 7.7 セーフモードとNIL

セーフモード修飾子 `~` （セクション3.4）は、エラーをNILに変換する。これにより、エラーが発生しうる操作をNIL安全パイプラインに組み込むことができる。

```ajisai
# パイプラインでの安全なGET
[ 1 2 3 ]
  == [ 10 ] ~ GET          # インデックス超過 → NIL
  == => [ 0 ]              # NILをデフォルト値で補完
# -> [ 0 ]

# MAP内での安全な操作
[ 1 0 2 ] : [ 10 ] SWAP ~ / ; MAP
# 0での除算 → そのイテレーションの結果がNILになる
# -> [ 10 NIL 5 ]

# FILTERと組み合わせた堅牢なパイプライン
[ 'hello' 42 'world' ]
  == : ~ NUM ; MAP          # 数値変換できない要素はNIL
  == : NIL = NOT ; FILTER   # NILを除外
  == => [ 0 ]               # 全部NILだった場合の安全策
```

セーフモードは「エラーの可能性を認識した上で意図的にNILとして処理する」ための仕組みである。無条件にすべてのワードに `~` を付けるような使い方は推奨しない。

### 7.8 エラーカテゴリ

Ajisaiの実行時エラーは以下のカテゴリに分類される。セーフモード修飾子 `~` はすべてのカテゴリのエラーをNILに変換する。

| カテゴリ | 説明 | 例 |
|---------|------|-----|
| StackUnderflow | スタックに十分な要素がない | `+`（スタックが空） |
| StructureError | 期待される構造と実際の構造が不一致 | `[ 'hello' ] [ 1 ] +` |
| UnknownWord | 辞書に存在しないワード | `UNKNOWNWORD` |
| DivisionByZero | ゼロ除算 | `[ 1 ] [ 0 ] /` |
| IndexOutOfBounds | インデックスが範囲外 | `[ 1 2 3 ] [ 10 ] GET` |
| LengthMismatch | ベクタ長の不一致（ブロードキャスト不可） | `[ 1 2 3 ] [ 1 2 ] +` |
| DepthLimitExceeded | 呼び出し深度制限（3）超過 | `A → B → C → D` |
| DimensionLimitExceeded | 次元制限（10次元）超過 | 10次元を超えるネスト |
| NoChange | 「変化なしはエラー」原則による検出 | `[ 1 ] REVERSE` |
| ModeUnsupported | ワードが対応しないモードの使用 | `'NAME' .. DEF` |
| BuiltinProtection | 組み込みワードの削除・上書き | `[ [ 1 ] ] 'GET' DEF` |

エラーメッセージは人間が読める形式で、エラーカテゴリ、期待された状態、実際の状態、および可能な場合はエラー発生箇所を含む。

---

## 8. 設計上の禁止事項

以下はAjisaiの設計に反するため、仕様として明確に禁止する:

1. **スタック操作ワード（DUP, SWAP, ROT, OVER等）の導入**: Ajisaiはこれらを持たない。同等の操作は `REORDER` や `.. GET` 等のVector操作で表現する
2. **次元制限（10）を超える構造の導入**
3. **呼び出し深度制限（3）を超える再帰チェーンの許容**
4. **型システムの導入**: すべての値は分数であり、型チェックは存在しない
5. **後方互換性の維持**: Ajisaiはプレリリース段階であり、後方互換性は常に破棄する。既存の動作を保護するためのフォールバック、非推奨パス、互換シムを導入してはならない

---

## 9. 開発原則

### 9.1 実装とメタ情報の一貫性

本仕様書（SPECIFICATION.md）、README.md、リファレンスページ（reference.html および public/docs/ 配下のHTMLファイル）、およびソースコード実装は、常に互いに整合していなければならない。いずれかに乖離が見つかった場合、速やかに修正する。

修正の方向は固定ではない:

- **仕様→実装**: 仕様の意図が正しく、実装が追いついていない場合
- **実装→仕様**: 実装上の発見や制約により、仕様側を更新すべき場合

重要なのは「仕様が常に正」ではなく、**実装とメタ情報（仕様・README・リファレンス）が乖離しないこと**である。

### 9.2 ソースコード品質

#### コメント

ソースコード内のコメントは極力省く。コードが自明であることを優先し、コメントが必要な箇所はコード自体の改善を検討する。やむを得ず記述する場合は「なぜ」を書き、「何を」は書かない。

#### デッドコードの禁止

使われていないコード（デッドコード）は即座に削除する。`#[allow(dead_code)]` や `#[allow(unused_variables)]` 等のコンパイラ警告抑制は、デッドコードの温存手段であり使用しない。未使用のパラメータ、到達不能なコードパス、呼び出し元のない関数は、将来の使用可能性に関わらず削除する。

#### 不要な間接層の禁止

メソッド呼び出しをそのまま委譲するだけのラッパー関数は作成しない。`val.is_vector()` で済む処理を `is_vector_value(val)` のような関数で包むことは、コードの可読性を下げる不要な間接層である。

### 9.3 後方互換性の破棄

Ajisaiはプレリリース段階にあり、後方互換性は一切保証しない。より良い設計が見つかった場合、既存の動作を躊躇なく破壊する。非推奨（deprecated）パスや互換レイヤーは導入しない。

---

## 10. 音楽DSL

音楽DSLは、Ajisaiの統一分数アーキテクチャを活用したドメイン拡張である。分数が「周波数/音長」を自然に表現できるという特性を利用し、ベクタを音楽構造として解釈する。

音楽DSLワード（`PLAY`, `SEQ`, `SIM`等の15ワード）は組み込みワードとして提供される（6.1 組み込みワードの分類原則を参照）。

### 10.1 分数の音楽的解釈

| 値 | 解釈 | 例 |
|-----|------|-----|
| `n`（整数） | nHz を 1スロット再生 | `440` → 440Hz, 1スロット |
| `n/d`（分数） | nHz を dスロット再生 | `440/2` → 440Hz, 2スロット |
| `0/d` | dスロット休符 | `0/2` → 2スロット休符 |
| `NIL` | 1スロット休符 | `NIL` → 休符 |
| 文字列 | 歌詞（出力のみ、時間消費なし） | `'Hello'` → 歌詞表示 |

この設計では、コア言語の分数リテラルをそのまま音楽パラメータとして読み替えている。新たな構文要素を導入する必要がない。

### 10.2 ワード詳細

**再生制御:**

| ワード | 機能 | 構文例 |
|--------|------|--------|
| `SEQ` | 順次再生モード（デフォルト） | `[ 440 550 660 ] SEQ PLAY` |
| `SIM` | 同時再生モード（和音） | `[ 440 550 660 ] SIM PLAY` |
| `PLAY` | 再生実行 | `[ 440/2 550 ] PLAY` |
| `CHORD` | ベクタを和音としてマーク | `[ 440 550 660 ] CHORD` |

`PLAY` は操作対象モードに対応する:
- `. PLAY`: スタックトップの1ベクタを再生
- `.. PLAY`: スタック上の全ベクタをマルチトラック再生

**スロット制御:**

| ワード | 機能 | 構文例 |
|--------|------|--------|
| `SLOT` | スロット時間の設定（秒） | `[ 0.25 ] SLOT` |

**エフェクト:**

| ワード | 機能 | 構文例 |
|--------|------|--------|
| `GAIN` | 音量設定（0.0〜1.0） | `[ 0.5 ] GAIN` |
| `GAIN-RESET` | 音量をデフォルト（1.0）にリセット | `GAIN-RESET` |
| `PAN` | ステレオ定位（-1.0左〜1.0右） | `[ -0.5 ] PAN` |
| `PAN-RESET` | 定位をセンター（0.0）にリセット | `PAN-RESET` |
| `FX-RESET` | 全エフェクトをリセット | `FX-RESET` |
| `ADSR` | ADSRエンベロープの設定 | `[ 440 ] [ 0.01 0.1 0.8 0.2 ] ADSR` |

**波形:**

| ワード | 機能 |
|--------|------|
| `SINE` | サイン波（デフォルト） |
| `SQUARE` | 矩形波 |
| `SAW` | ノコギリ波 |
| `TRI` | 三角波 |

### 10.3 使用例

```ajisai
# 基本: 3音の順次再生
[ 440 550 660 ] SEQ PLAY

# 和音
[ 440 550 660 ] SIM PLAY

# 音長指定（440Hzを2スロット、550Hzを1スロット）
[ 440/2 550/1 ] PLAY

# 休符の挿入
[ 440 NIL 550 ] PLAY

# 歌詞付き
[ 440/2 'Hello' 550/2 'World' ] PLAY

# マルチトラック（スタック上の全ベクタを同時再生）
[ 440 550 ] [ 220 275 ] .. SIM PLAY
```

### 10.4 コア言語機能との組み合わせ

音楽DSLの価値は、コア言語のVector操作と自然に組み合わせられる点にある。

```ajisai
# 純正律の音階をカスタムワードで定義（国際表記）
: [ 261.63 ] ; 'C4' DEF
: C4 [ 9/8 ] * ; 'D4' DEF
: C4 [ 5/4 ] * ; 'E4' DEF
: C4 [ 4/3 ] * ; 'F4' DEF
: C4 [ 3/2 ] * ; 'G4' DEF
: C4 [ 5/3 ] * ; 'A4' DEF
: C4 [ 15/8 ] * ; 'B4' DEF
: C4 [ 2 ] * ; 'C5' DEF

# カスタムワードとVector操作でメロディを構築
C4 D4 E4 G4 [ 4 ] .. CONCAT PLAY

# 和音
C4 E4 G4 [ 3 ] .. CONCAT SIM PLAY
```

このように、音楽固有のワード（SEQ, SIM, PLAY等）はドメインへの入口を提供するが、メロディの構築自体にはコア言語のカスタムワード定義（DEF）やVector操作（CONCAT等）がそのまま使われる。音階名（C4, D4等）は組み込みワードの算術で定義できるためサンプルカスタムワードとして提供される。

---

## 11. 外部データ連携

### 11.1 JSON ↔ Ajisai データ型マッピング

| JSONの型 | Ajisaiの表現 | 備考 |
|----------|-------------|------|
| `null` | `NIL` | |
| `Number` | `Scalar(Fraction)` | 浮動小数点は `f64` をそのまま保持し、有理数変換は行わない。変換が必要な場合はユーザーが明示的に行う |
| `String` | `Vector<Char>` + `DisplayHint::String` | 既存の文字列表現と統一 |
| `Boolean` | `Scalar(1)` / `Scalar(0)` + `DisplayHint::Boolean` | |
| `Array` | `Vector` | 既存のVector操作をそのまま適用可能 |
| `Object` | `Vector<[key, value]>` | キーはStringベクター、値は再帰的にマップ |

**Objectの設計注記**: ObjectをVectorのリストとして表現するため、アクセスにはヘルパーワード（`JSON-GET`, `JSON-KEYS`, `JSON-SET`）が必要。

**ネスト深度の注記**: JSONのパース中にAjisaiの表現が10次元を超えるネスト構造となる場合、`PARSE` はエラーを返し `NIL` をプッシュする。エラーメッセージにはどの階層で超過したかを記録する。

### 11.2 新規組み込みワード

#### `PARSE` （Map型）
- **入力**: スタックトップの文字列（JSONテキスト）
- **出力**: 対応するAjisai Value（上記マッピングに従う）
- **エラー時**: `NIL` をプッシュし、エラーメッセージをステータスに記録
- **ネスト超過時**: 10次元を超えるネストが検出された場合もエラーとして扱い、`NIL` をプッシュしてステータスに「ネスト上限（10次元）を超過しました」と記録する

#### `STRINGIFY` （Map型）
- **入力**: スタックトップの任意のValue
- **出力**: JSON形式の文字列（`Vector<Char>` + `DisplayHint::String`）
- **Object表現**: `[ [key value] ... ]` をJSONオブジェクトとして出力

#### `INPUT` （シグネチャ型なし）
- **入力**: なし（スタック操作不要）
- **出力**: GUIのInputエリアにあるテキスト内容を文字列としてプッシュ
- **実装注記**: `Interpreter` 構造体が保持する `input_buffer: String` フィールドから読み取る

#### `OUTPUT` （シグネチャ型なし）
- **入力**: スタックトップの値（消費する）
- **出力**: GUIのOutputエリアにその文字列表現を書き込む
- **設計理由**: スタックトップの自動転送は副作用が大きく、Ajisaiのスタック指向と相性が悪いため、ユーザーが明示的に呼ぶ設計とする

#### Objectヘルパーワード

| ワード名 | シグネチャ | 動作 |
|---------|:----------:|------|
| `JSON-GET` | Form | `( obj key -- value )` キー文字列でObjectから値を取り出す。見つからない場合は `NIL` |
| `JSON-KEYS` | Form | `( obj -- keys-vector )` ObjectのキーをVectorとして返す |
| `JSON-SET` | Form | `( obj key value -- obj' )` Objectにキーバリューを追加・更新した新しいObjectを返す |

### 11.3 I/Oデータフロー

```
[実行前]
JS: interpreter.set_input_buffer(inputTextarea.value)

[Ajisaiコード実行]
INPUT    → input_bufferの内容を文字列としてスタックにプッシュ
PARSE    → スタックトップのJSON文字列をAjisai Valueに変換
...      → Vector演算で加工
STRINGIFY → Ajisai ValueをJSON文字列に変換
OUTPUT   → output_bufferに書き込み

[実行後]
JS: interpreter.get_output_buffer() でOutputエリアに反映
```

### 11.4 使用例

```ajisai
# JSON配列のパースとVector演算
INPUT PARSE
[ 2 ] *
STRINGIFY OUTPUT
# Input: [1, 2, 3] → Output: [2, 4, 6]

# JSONオブジェクトのキー取得
INPUT PARSE
'name' JSON-GET
STRINGIFY OUTPUT
# Input: {"name": "Ajisai", "version": 1} → Output: "Ajisai"

# JSONオブジェクトの更新
INPUT PARSE
'version' [ 2 ] JSON-SET
STRINGIFY OUTPUT
# Input: {"name": "Ajisai", "version": 1} → Output: {"name":"Ajisai","version":2}
```

---

## 変更履歴

| バージョン | 日付 | 内容 |
|-----------|------|------|
| v0.1.0 | 2026-02-06 | 初期骨組み作成 |
| v0.1.1 | 2026-02-06 | 「変化なしはエラー」原則を追加 |
| v0.1.2 | 2026-02-06 | デフォルト消費原則を追加（GET/LENGTHの消費性を均一化） |
| v0.1.3 | 2026-02-06 | スタック全体モードでの消費性、保持モードの範囲を明確化 |
| v0.2.0 | 2026-02-06 | NIL、矩形制約、コメント、ブロードキャスト詳細、DisplayHint、Fraction型、呼び出し深度詳細、括弧表示規則を統合。Documentation/*.mdの内容を本仕様書に一本化 |
| v0.3.0 | 2026-02-06 | ワードシグネチャ型（A: 要素変換、B: 集合操作、C: 二項演算）を導入。機能カテゴリとの二軸分類表を追加 |
| v0.4.0 | 2026-02-06 | シグネチャ型名称を写像型/構造型/還元型に改称。NIL安全性と三値論理（Kleene強三値論理）セクションを追加 |
| v0.5.0 | 2026-02-06 | 音楽DSLワードをコア言語から分離し「拡張ワードドメイン（サンプル）」セクションとして再配置 |
| v0.6.0 | 2026-02-09 | 組み込みワードの分類原則を明文化。音楽DSLワードを組み込みワードとして再分類 |
| v0.7.0 | 2026-02-10 | セーフモード修飾子（~）を追加。エラーハンドリングの仕様を策定 |
| v0.8.0 | 2026-02-12 | GUI辞書表示にワードボタンの色エンコーディング仕様を追加。シグネチャ型を背景色で表示 |
| v0.9.0 | 2026-02-13 | 仕様と実装の整合性レビュー。Value構造体を実装に合わせて更新（概念モデルと実装構造の分離）。NIL内部表現をValueData::Nilに修正。TIMES/EXEC/EVAL/COLLECT/!の詳細仕様を追加。ワード一覧テーブルを実装の全組み込みワードで網羅 |
| v0.9.1 | 2026-02-13 | NILのメタファーを「空の容器」から「泡」に変更 |
| v0.10.0 | 2026-02-13 | 開発原則セクションを追加（実装とメタ情報の一貫性、ソースコメント最小化、後方互換性の破棄）。設計上の禁止事項に後方互換性維持の禁止を追加 |
| v0.11.0 | 2026-02-20 | ネスト上限を3可視次元（4次元）から9可視次元（10次元）に拡張。括弧3種×3サイクルの構造的根拠を明記。次元モデルを1次元起点の10次元体系に改定 |
| v0.12.0 | 2026-02-20 | 外部データ連携セクション（11章）を新設。JSON↔Ajisaiデータ型マッピング、PARSE/STRINGIFY/INPUT/OUTPUT/JSON-GET/JSON-KEYS/JSON-SETの7ワード仕様を策定 |
