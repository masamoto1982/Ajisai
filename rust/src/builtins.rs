// rust/src/builtins.rs

use std::collections::{HashMap, HashSet};
use crate::types::WordDefinition;

pub fn register_builtins(dictionary: &mut HashMap<String, WordDefinition>) {
    for (name, description, _) in get_builtin_definitions() {
        dictionary.insert(name.to_string(), WordDefinition {
            lines: vec![],
            is_builtin: true,
            description: Some(description.to_string()),
            dependencies: HashSet::new(),
            original_source: None,
        });
    }
}

pub fn get_builtin_definitions() -> Vec<(&'static str, &'static str, &'static str)> {
    vec![
        // 操作対象指定
        (".", "操作対象をスタックトップに設定（デフォルト）｜. + → スタックトップに加算", "Target"),
        ("..", "操作対象をスタック全体に設定｜.. + [ 3 ] → スタック全要素に3を加算", "Target"),

        // 入力支援
        ("'", "シングルクォートを入力｜' → '", "Input Helper"),
        ("FRAME", "形状指定でブラケット構造を入力｜[ 2 3 ] FRAME → { ( ) ( ) ( ) } { ( ) ( ) ( ) }", "Input Helper"),

        // 位置指定操作(0オリジン)
        ("GET", "指定位置の要素を取得（0オリジン）｜[ 10 20 30 ] [ 0 ] GET → [ 10 20 30 ] [ 10 ]", "Position"),
        ("INSERT", "指定位置に要素を挿入｜[ 1 3 ] [ 1 2 ] INSERT → [ 1 2 3 ]", "Position"),
        ("REPLACE", "指定位置の要素を置換｜[ 1 2 3 ] [ 0 9 ] REPLACE → [ 9 2 3 ]", "Position"),
        ("REMOVE", "指定位置の要素を削除｜[ 1 2 3 ] [ 0 ] REMOVE → [ 2 3 ]", "Position"),

        // 量指定操作(1オリジン)
        ("LENGTH", "ベクタの長さを取得｜[ 1 2 3 4 5 ] LENGTH → [ 1 2 3 4 5 ] [ 5 ]", "Quantity"),
        ("TAKE", "先頭または末尾からN個の要素を取得｜[ 1 2 3 4 5 ] [ 3 ] TAKE → [ 1 2 3 ]", "Quantity"),

        // Vector構造操作
        ("SPLIT", "ベクタを指定サイズで分割｜[ 1 2 3 4 5 6 ] [ 2 3 ] SPLIT → [ 1 2 ] [ 3 4 5 ] [ 6 ]", "Vector"),
        ("CONCAT", "ベクタを連結｜[ 1 2 ] [ 3 4 ] CONCAT → [ 1 2 3 4 ]", "Vector"),
        ("REVERSE", "ベクタの要素を反転｜[ 1 2 3 ] REVERSE → [ 3 2 1 ]", "Vector"),
        ("RANGE", "数値範囲を生成｜[ 0 5 ] RANGE → [ 0 1 2 3 4 5 ]", "Vector"),
        ("SORT", "ベクタの要素を昇順に並べ替える｜[ 3 1 2 ] SORT → [ 1 2 3 ]", "Sorting"),

        // 定数（スタックに値をプッシュ）
        ("TRUE", "真偽値TRUEをスタックにプッシュ｜TRUE → TRUE", "Constant"),
        ("FALSE", "真偽値FALSEをスタックにプッシュ｜FALSE → FALSE", "Constant"),
        ("NIL", "NIL（空ベクタ）をスタックにプッシュ｜NIL → NIL", "Constant"),

        // 文字列操作
        ("CHARS", "文字列を文字ベクタに分解｜[ 'hello' ] CHARS → [ 'h' 'e' 'l' 'l' 'o' ]", "String"),
        ("JOIN", "文字列ベクタを連結｜[ 'h' 'e' 'l' 'l' 'o' ] JOIN → [ 'hello' ]", "String"),

        // パース・変換
        ("NUM", "文字列を数値にパース｜'123' NUM → [ 123 ]、パース失敗時はNIL", "Parse/Convert"),
        ("STR", "値を文字列に変換（Stringify）｜123 STR → '123'", "Parse/Convert"),
        ("BOOL", "真偽値に正規化｜'true' BOOL → TRUE、100 BOOL → TRUE", "Parse/Convert"),
        ("CHR", "数値をUnicode文字に変換｜65 CHR → 'A'", "Parse/Convert"),

        // 日時操作（タイムゾーンは変換パラメータ、データとして持たない）
        ("NOW", "現在のUnixタイムスタンプ（絶対時刻）を取得｜NOW → [ 1732531200 ]", "DateTime"),
        ("DATETIME", "タイムスタンプを日時ベクタに変換（TZ必須）｜[ 1732531200 ] 'LOCAL' DATETIME → [ 2024 11 25 23 0 0 ]", "DateTime"),
        ("TIMESTAMP", "日時ベクタをタイムスタンプに変換（TZ必須）｜[ 2024 11 25 23 0 0 ] 'LOCAL' TIMESTAMP → [ 1732531200 ]", "DateTime"),

        // 算術演算
        ("+", "要素ごとの加算または集約｜[ 1 2 ] [ 3 4 ] + → [ 4 6 ]", "Arithmetic"),
        ("-", "要素ごとの減算または集約｜[ 5 3 ] [ 2 1 ] - → [ 3 2 ]", "Arithmetic"),
        ("*", "要素ごとの乗算または集約｜[ 2 3 ] [ 4 5 ] * → [ 8 15 ]", "Arithmetic"),
        ("/", "要素ごとの除算または集約｜[ 10 20 ] [ 2 4 ] / → [ 5 5 ]", "Arithmetic"),

        // 比較演算
        ("=", "ベクタが等しいか判定｜[ 1 2 ] [ 1 2 ] = → [ TRUE ]", "Comparison"),
        ("<", "ベクタが小さいか判定｜[ 1 ] [ 2 ] < → [ TRUE ]", "Comparison"),
        ("<=", "ベクタが小さいまたは等しいか判定｜[ 1 ] [ 1 ] <= → [ TRUE ]", "Comparison"),
        (">", "ベクタが大きいか判定｜[ 3 ] [ 2 ] > → [ TRUE ]", "Comparison"),
        (">=", "ベクタが大きいまたは等しいか判定｜[ 2 ] [ 2 ] >= → [ TRUE ]", "Comparison"),

        // 論理演算
        ("AND", "ベクタの論理積｜[ TRUE FALSE ] [ TRUE TRUE ] AND → [ TRUE FALSE ]", "Logic"),
        ("OR", "ベクタの論理和｜[ TRUE FALSE ] [ FALSE FALSE ] OR → [ TRUE FALSE ]", "Logic"),
        ("NOT", "ベクタの論理否定｜[ TRUE FALSE ] NOT → [ FALSE TRUE ]", "Logic"),

        // 制御構造(ガード)
        (":", "条件分岐のガード区切り｜条件 : 処理 : 条件 : 処理 : デフォルト処理", "Control"),

        // 高階関数
        ("MAP", "各要素にワードを適用｜[ 1 2 3 ] '2倍' MAP → [ 2 4 6 ]", "Higher-Order"),
        ("FILTER", "条件に合う要素を抽出｜[ 1 2 3 4 ] '偶数?' FILTER → [ 2 4 ]", "Higher-Order"),
        ("FOLD", "初期値付き畳み込み｜[ 1 2 3 4 ] [ 0 ] '+' FOLD → [ 10 ]", "Higher-Order"),

        // 入出力
        ("PRINT", "スタックトップを出力して削除｜[ 42 ] PRINT → （42を出力）", "I/O"),

        // 音楽DSL
        ("SEQ", "順次再生モードを設定｜[ 440 550 660 ] SEQ PLAY → 3音を順番に再生", "Music"),
        ("SIM", "同時再生モードを設定｜[ 440 550 660 ] SIM PLAY → 3音を同時に再生（和音）", "Music"),
        ("PLAY", "音声を再生｜[ 440/2 550 NIL 660 ] PLAY → 440Hzを2スロット再生→550Hzを1スロット→休符→660Hz", "Music"),

        // カスタムワード管理
        ("DEF", "カスタムワードを定義｜[ [ 2 ] * ] 'DOUBLE' DEF", "Word Management"),
        ("DEL", "カスタムワードを削除｜'不要なワード' DEL", "Word Management"),
        ("?", "ワード定義を表示｜'2倍' ?", "Word Management"),

        // 制御フロー（TIMES/WAIT）
        ("TIMES", "コードをN回繰り返し実行｜[ [ 1 ] + ] [ 5 ] TIMES", "Control Flow"),
        ("WAIT", "指定ミリ秒後にワードを実行｜'処理' [ 1000 ] WAIT", "Control Flow"),
        ("!", "強制実行フラグ｜依存のあるワードのDEL/DEFを許可｜! 'WORD' DEL", "Control Flow"),

        // 基本数学関数
        ("MOD", "剰余（数学的）｜[ 7 ] [ 3 ] MOD → [ 1 ]", "Math"),
        ("FLOOR", "切り捨て（負の無限大方向）｜[ 7/3 ] FLOOR → [ 2 ]", "Math"),
        ("CEIL", "切り上げ（正の無限大方向）｜[ 7/3 ] CEIL → [ 3 ]", "Math"),
        ("ROUND", "四捨五入（0から遠い方向）｜[ 5/2 ] ROUND → [ 3 ]", "Math"),

        // 暗号論的乱数生成
        ("CSPRNG", "暗号論的疑似乱数を生成｜[ 6 ] [ 1 ] CSPRNG → [ 0 ]〜[ 5/6 ]（自動約分）、[ 5 ] CSPRNG → 5個生成", "Random"),

        // ハッシュ関数
        ("HASH", "任意の値を決定論的にハッシュ化｜'hello' HASH → [ 0.xxx ]、[ 128 ] 'hello' HASH → 128ビット出力", "Hash"),
    ]
}

pub fn get_builtin_detail(name: &str) -> String {
    match name {
        // ============================================================================
        // 操作対象指定
        // ============================================================================

        "." => r#"# . - スタックトップ指定

## 機能
操作対象をスタックトップ（最上位のベクタ）に設定します。
デフォルトの動作モードなので、通常は明示的な指定は不要です。

## 使用法
. WORD
→ 次のワードをスタックトップに対して実行

## 使用例
[ 1 2 3 ] . LENGTH     # → [ 1 2 3 ] [ 3 ]
[ 1 2 3 ] LENGTH       # 同じ結果（デフォルト）

## 注意
- これはデフォルトモードなので、通常は省略可能です
- ワード実行後、自動的にこのモードにリセットされます"#.to_string(),

        ".." => r#"# .. - スタック全体指定

## 機能
操作対象をスタック全体に設定します。
多くの組み込みワードがスタックモードに対応しています。

## 使用法
.. WORD
→ 次のワードをスタック全体に対して実行

## 使用例
a b c [ 1 ] .. GET      # → a b c [ b ]
（スタック全体から1番目を取得）

1 2 3 4 5 .. LENGTH     # → 1 2 3 4 5 [ 5 ]
（スタックの要素数を取得）

a b c .. REVERSE        # → c b a
（スタック全体を反転）

## 対応ワード
GET, INSERT, REPLACE, REMOVE, LENGTH, TAKE, SPLIT,
CONCAT, REVERSE, LEVEL, +, -, *, /, MAP など

## 注意
- ワード実行後、自動的にスタックトップモード(.)にリセットされます"#.to_string(),

        // ============================================================================
        // 位置指定操作（0オリジン）
        // ============================================================================

        "GET" => r#"# GET - 指定位置の要素を取得

## 機能
ベクタまたはスタックから、指定した位置（0オリジン）の要素を取得します。
負のインデックスを使用すると、末尾から数えて要素を取得できます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] GET
→ 元のベクタを保持し、取得した要素を新しいベクタとしてプッシュ

## 使用法（Stackモード）
要素... [ インデックス ] .. GET
→ スタック全体から指定位置の要素を取得

## 使用例
[ 10 20 30 ] [ 0 ] GET    # → [ 10 20 30 ] [ 10 ]  (0番目=最初の要素)
[ 10 20 30 ] [ 1 ] GET    # → [ 10 20 30 ] [ 20 ]  (1番目=2番目の要素)
[ 10 20 30 ] [ -1 ] GET   # → [ 10 20 30 ] [ 30 ]  (-1=末尾の要素)
[ 10 20 30 ] [ -2 ] GET   # → [ 10 20 30 ] [ 20 ]  (-2=末尾から2番目)

a b c [ 1 ] .. GET     # → a b c [ b ]  (スタックの1番目を取得)

## 注意
- インデックスが範囲外の場合はエラー
- 空のベクタ/スタックに対する操作はエラー"#.to_string(),

        "INSERT" => r#"# INSERT - 指定位置に要素を挿入

## 機能
ベクタまたはスタックの指定位置（0オリジン）に要素を挿入します。
負のインデックスを使用すると、末尾から数えた位置に挿入できます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス 挿入する要素 ] INSERT
→ 指定位置に要素を挿入した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス 挿入する要素 ] .. INSERT
→ スタックの指定位置に要素を挿入

## 使用例
[ 1 3 ] [ 1 2 ] INSERT        # → [ 1 2 3 ]  (1番目の位置に2を挿入)
[ a c ] [ 0 b ] INSERT        # → [ b a c ]  (0番目=先頭に挿入)
[ 1 2 3 ] [ -1 9 ] INSERT     # → [ 1 2 9 3 ]  (末尾の要素の前に挿入)
[ 1 2 3 ] [ 3 4 ] INSERT      # → [ 1 2 3 4 ]  (末尾への追加も可能)

a c [ 1 b ] .. INSERT          # → a b c  (スタックの1番目にbを挿入)

## 注意
- 引数は [ インデックス 挿入する要素 ] 形式で指定
- 負のインデックスは要素の位置を指します（-1=末尾の要素の位置）"#.to_string(),

        "REPLACE" => r#"# REPLACE - 指定位置の要素を置換

## 機能
ベクタまたはスタックの指定位置（0オリジン）の要素を新しい要素で置き換えます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス 新しい要素 ] REPLACE
→ 指定位置の要素を置換した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス 新しい要素 ] .. REPLACE
→ スタックの指定位置の要素を置換

## 使用例
[ 1 2 3 ] [ 0 9 ] REPLACE    # → [ 9 2 3 ]  (0番目=最初の要素を9に)
[ 1 2 3 ] [ 1 5 ] REPLACE    # → [ 1 5 3 ]  (1番目=2番目の要素を5に)
[ 1 2 3 ] [ -1 9 ] REPLACE   # → [ 1 2 9 ]  (-1=末尾を9に)

a b c [ 1 X ] .. REPLACE      # → a X c  (スタックの1番目をXに)

## 注意
- 引数は [ インデックス 新しい要素 ] 形式で指定
- インデックスが範囲外の場合はエラー"#.to_string(),

        "REMOVE" => r#"# REMOVE - 指定位置の要素を削除

## 機能
ベクタまたはスタックの指定位置（0オリジン）の要素を削除します。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] REMOVE
→ 指定位置の要素を削除した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス ] .. REMOVE
→ スタックの指定位置の要素を削除

## 使用例
[ 1 2 3 ] [ 0 ] REMOVE      # → [ 2 3 ]  (0番目=最初の要素を削除)
[ 1 2 3 ] [ 1 ] REMOVE      # → [ 1 3 ]  (1番目=2番目の要素を削除)
[ 1 2 3 ] [ -1 ] REMOVE     # → [ 1 2 ]  (-1=末尾を削除)
[ 1 2 3 4 ] [ -2 ] REMOVE   # → [ 1 2 4 ]  (-2=末尾から2番目を削除)

a b c [ 1 ] .. REMOVE    # → a c  (スタックの1番目を削除)

## 注意
- インデックスが範囲外の場合はエラー"#.to_string(),

        // ============================================================================
        // 量指定操作（1オリジン）
        // ============================================================================

        "LENGTH" => r#"# LENGTH - 要素数を取得

## 機能
ベクタまたはスタック全体の要素数を取得します。

## 使用法（StackTopモード）
[ 要素... ] LENGTH
→ 元のベクタを保持し、要素数を新しいベクタとしてプッシュ

## 使用法（Stackモード）
要素... .. LENGTH
→ スタック全体の要素数をプッシュ

## 使用例
[ 1 2 3 4 5 ] LENGTH    # → [ 1 2 3 4 5 ] [ 5 ]  (5個の要素)
[ ] LENGTH              # → NIL [ 0 ]  (空ベクタ = NIL、長さ0)
[ 42 ] LENGTH           # → [ 42 ] [ 1 ]  (1個の要素)

a b c d .. LENGTH    # → a b c d [ 4 ]  (スタックに4個)

## 注意
- StackTopモードでは対象がベクタまたはNILでない場合はエラー
- 空ベクタ [ ] はNILとして扱われ、長さは0"#.to_string(),

        "TAKE" => r#"# TAKE - 先頭または末尾から指定数の要素を取得

## 機能
正の数を指定すると先頭から、負の数を指定すると末尾から、
指定した個数の要素を取得します。

## 使用法（StackTopモード）
[ 要素... ] [ 個数 ] TAKE
→ 取得した要素からなる新しいベクタを返す

## 使用法（Stackモード）
要素... [ 個数 ] .. TAKE
→ スタックを指定個数の要素に切り詰める

## 使用例
[ 1 2 3 4 5 ] [ 3 ] TAKE     # → [ 1 2 3 ]  (先頭から3個)
[ 1 2 3 4 5 ] [ -2 ] TAKE    # → [ 4 5 ]  (末尾から2個)
[ 1 2 3 4 5 ] [ 1 ] TAKE     # → [ 1 ]  (先頭1個)

a b c d e [ 3 ] .. TAKE   # → a b c  (先頭3個だけ残す)
a b c d e [ -2 ] .. TAKE  # → d e  (末尾2個だけ残す)

## 注意
- 指定個数が要素数を超える場合はエラー
- 0を指定した場合の動作は未定義"#.to_string(),

        "SPLIT" => r#"# SPLIT - 指定サイズで分割

## 機能
ベクタまたはスタックを、指定したサイズに分割します。
複数のサイズを指定でき、余りは最後のベクタに含まれます。

## 使用法（StackTopモード）
[ 要素... ] [ サイズ1 サイズ2 ... ] SPLIT
→ 分割された複数のベクタをプッシュ

## 使用法（Stackモード）
要素... [ サイズ1 サイズ2 ... ] .. SPLIT
→ スタックを分割し、結果をベクタとしてプッシュ

## 使用例
[ 1 2 3 4 5 6 ] [ 2 3 1 ] SPLIT
# → [ 1 2 ] [ 3 4 5 ] [ 6 ]  (2個、3個、1個に分割)

[ 1 2 3 4 5 6 ] [ 2 2 ] SPLIT
# → [ 1 2 ] [ 3 4 ] [ 5 6 ]  (余りも自動的にベクタに)

a b c d e [ 2 1 ] .. SPLIT
# → [ a b ] [ c ] [ d e ]  (スタックを分割)

## 注意
- サイズは [ サイズ1 サイズ2 ... ] 形式で指定
- サイズの合計が要素数を超える場合はエラー
- 最低1つのサイズ指定が必要"#.to_string(),

        // ============================================================================
        // ベクタ構造操作
        // ============================================================================

        "CONCAT" => r#"# CONCAT - ベクタを連結

## 機能
複数のベクタを1つに連結します。
デフォルトは2個、個数を指定可能。負数で逆順連結。

## 使用法（StackTopモード）
vec1 vec2 CONCAT              # 2個を連結（デフォルト）
vec1 vec2 vec3 [ 3 ] CONCAT   # 3個を連結
vec1 vec2 vec3 [ -3 ] CONCAT  # 3個を逆順で連結

## 使用法（Stackモード）
要素... .. CONCAT          # スタック全体を連結
要素... [ 個数 ] .. CONCAT # 指定個数を連結

## 使用例
[ a ] [ b ] CONCAT                # → [ a b ]  (デフォルト2個)
[ a ] [ b ] [ c ] [ 3 ] CONCAT    # → [ a b c ]  (3個を連結)
[ a ] [ b ] [ c ] [ -3 ] CONCAT   # → [ c b a ]  (逆順)
[ 1 ] [ 2 3 ] [ 4 ] [ 3 ] CONCAT  # → [ 1 2 3 4 ]

a b c .. CONCAT                # → [ a b c ]  (全体を連結)
a b c [ 2 ] .. CONCAT          # → a [ b c ]  (2個だけ連結)

## 注意
- ベクタでない要素も単独要素として含まれます
- 最初のベクタの括弧タイプが結果に適用されます"#.to_string(),

        "REVERSE" => r#"# REVERSE - 要素の順序を反転

## 機能
ベクタまたはスタックの要素順序を反転します。
「変化なしはエラー」原則により、要素が2個未満や回文の場合はエラー。

## 使用法（StackTopモード）
[ 要素... ] REVERSE
→ 要素順を反転した新しいベクタを返す

## 使用法（Stackモード）
要素... .. REVERSE
→ スタックの要素順を反転

## 使用例
[ a b c ] REVERSE      # → [ c b a ]
[ 1 2 3 4 ] REVERSE    # → [ 4 3 2 1 ]

a b c .. REVERSE    # → c b a

## エラーケース
[ 1 ] REVERSE          # エラー：1要素のみ（変化なし）
[ a b a ] REVERSE      # エラー：回文（変化なし）
[ ] REVERSE            # エラー：空ベクタ（変化なし）

## 注意
- 変化が生じない場合は必ずエラーになります"#.to_string(),

        "RANGE" => r#"# RANGE - 数値範囲を生成

## 機能
startからendまでの整数の範囲（等差数列）を生成します。
オプションでstep（増分）を指定可能です。

## 使用法
[ start end ] RANGE
→ 範囲ベクタを生成

[ start end step ] RANGE
→ step間隔の範囲ベクタを生成

## 使用例
[ 0 5 ] RANGE              # → [ 0 1 2 3 4 5 ]
[ 1 10 ] RANGE             # → [ 1 2 3 4 5 6 7 8 9 10 ]
[ 0 10 2 ] RANGE           # → [ 0 2 4 6 8 10 ]  (偶数)
[ 10 0 -2 ] RANGE          # → [ 10 8 6 4 2 0 ]  (降順)
[ 5 5 ] RANGE              # → [ 5 ]  (単一要素)

[ 0 5 ] .. RANGE           # Stackモードでも同じ引数形式

## 活用例
# MAPと組み合わせてインデックス付き処理
[ 0 4 ] RANGE '処理' MAP

## エラーケース
[ 0 10 0 ] RANGE       # エラー：stepが0
[ 0 10 -1 ] RANGE      # エラー：無限シーケンス（start < end だが step < 0）
[ 10 0 1 ] RANGE       # エラー：無限シーケンス（start > end だが step > 0）

## 注意
- 引数は [ start end ] または [ start end step ] 形式で指定
- endの値は範囲に含まれます（inclusive）
- stepのデフォルトは自動判定（start <= end なら 1、そうでなければ -1）
- 整数のみサポート"#.to_string(),

        // ============================================================================
        // ソート
        // ============================================================================

        "SORT" => r#"# SORT - ベクタの要素を昇順に並べ替える

## 機能
ベクタまたはスタック内の数値を昇順にソートします。
Ajisaiでは全ての数値が内部的に分数として表現されているため、
整数・分数・混在データのいずれも正確にソートできます。

## 使用法（StackTopモード）
[ 数値... ] SORT
→ 昇順にソートされたベクタを返す

## 使用法（Stackモード）
数値... .. SORT
→ スタック全体を昇順にソート

## 使用例
# 整数のソート
[ 32 8 2 18 ] SORT         # → [ 2 8 18 32 ]

# 分数のソート
[ 1/2 1/3 2/3 ] SORT       # → [ 1/3 1/2 2/3 ]

# 混在もOK
[ 3 1/2 2 1/4 ] SORT       # → [ 1/4 1/2 2 3 ]

# Stackモード
64 25 12 22 11 .. SORT     # スタック全体が昇順に

## エラーケース
[ 'a' 'b' ] SORT           # エラー：数値以外を含む
[ 1 ] SORT                 # エラー：1要素のみ（変化なし）
[ 1 2 3 ] SORT             # エラー：既にソート済み（変化なし）
[ 1 1 1 ] SORT             # エラー：全要素が同じ（変化なし）

## 注意
- 数値（整数・分数）のみをソート対象とします
- 「変化なしはエラー」原則により、ソート前後で変化がない場合はエラー
- 負の数も正しくソートされます"#.to_string(),

        // ============================================================================
        // 文字列操作
        // ============================================================================

        "CHARS" => r#"# CHARS - 文字列を文字ベクタに分解

## 機能
文字列を1文字ずつの文字列ベクタに分解します。
UTF-8マルチバイト文字（日本語など）も正しく処理されます。

## 使用法（StackTopモード）
[ 'string' ] CHARS
→ 文字ベクタ

## 使用法（Stackモード）
str1 str2 ... .. CHARS
→ 各文字列を文字ベクタに変換

## 使用例
[ 'hello' ] CHARS                # → [ 'h' 'e' 'l' 'l' 'o' ]
[ '日本語' ] CHARS               # → [ '日' '本' '語' ]
[ 'a' ] CHARS                    # → [ 'a' ]

'abc' 'xyz' .. CHARS             # → [ 'a' 'b' 'c' ] [ 'x' 'y' 'z' ]

## 活用例（既存ワードとの組み合わせ）
# 文字列を反転
[ 'hello' ] CHARS REVERSE JOIN   # → [ 'olleh' ]

# 文字列の長さ
[ 'hello' ] CHARS LENGTH         # → [ 'h' 'e' 'l' 'l' 'o' ] [ 5 ]

# 特定位置の文字を取得
[ 'hello' ] CHARS [ 1 ] GET      # → [ ... ] [ 'e' ]

# 部分文字列
[ 'hello' ] CHARS [ 3 ] TAKE JOIN  # → [ 'hel' ]

## エラーケース
[ '' ] CHARS                     # エラー: 空文字列
[ 42 ] CHARS                     # エラー: 数値型
[ [ 'a' ] ] CHARS                # エラー: ベクタ型

## 注意
- String型のみ受け付けます
- 空文字列はエラー（"No change is an error"原則）
- JOINワードで元の文字列に戻せます"#.to_string(),

        "JOIN" => r#"# JOIN - 文字列ベクタを連結

## 機能
文字列のベクタを連結して単一の文字列にします。
CHARSワードの逆操作として使用できます。

## 使用法（StackTopモード）
[ str1 str2 ... ] JOIN
→ 連結された文字列

## 使用法（Stackモード）
vec1 vec2 ... .. JOIN
→ 各ベクタを連結した文字列に変換

## 使用例
[ 'h' 'e' 'l' 'l' 'o' ] JOIN     # → [ 'hello' ]
[ 'hel' 'lo' ] JOIN              # → [ 'hello' ]
[ '日' '本' '語' ] JOIN          # → [ '日本語' ]
[ 'a' ] JOIN                     # → [ 'a' ]

[ 'a' 'b' ] [ 'x' 'y' ] .. JOIN  # → [ 'ab' ] [ 'xy' ]

## 活用例（CHARSとの組み合わせ）
# 文字列を反転
[ 'hello' ] CHARS REVERSE JOIN   # → [ 'olleh' ]

# 特定文字を除去（フィルタ）
# IS_NOTSPACEを定義済みとして
[ 'a b c' ] CHARS 'IS_NOTSPACE' FILTER JOIN  # → [ 'abc' ]

# 文字を変換（MAP）
# UPPER_CHARを定義済みとして
[ 'hello' ] CHARS 'UPPER_CHAR' MAP JOIN  # → [ 'HELLO' ]

## エラーケース
[ ] JOIN                         # エラー: 空ベクタ
[ 1 2 3 ] JOIN                   # エラー: 数値を含む
[ 'a' 1 'b' ] JOIN               # エラー: 混在型

## 注意
- 全要素がString型である必要があります
- 空ベクタはエラー
- 数値や他の型を含むとエラー"#.to_string(),

        // ============================================================================
        // パース・変換（セルフホスティング対応）
        // ============================================================================

        "NUM" => r#"# NUM - 文字列を数値にパース

## 機能
文字列を解析して数値（分数）を生成します。
セルフホスティング（言語自身によるパーサー実装）のための基本操作です。

## 使用法
'文字列' NUM
→ パース成功: 数値を返す
→ パース失敗: NILを返す

## 使用例
'123' NUM              # → [ 123 ]
'1/3' NUM              # → [ 1/3 ]
'-42' NUM              # → [ -42 ]
'3.14' NUM             # → [ 157/50 ]（小数も分数として解釈）
'ABC' NUM              # → NIL（パース失敗）
'' NUM                 # → NIL（空文字列）

## 「変化なしはエラー」原則
123 NUM                # エラー: 既に数値
TRUE NUM               # エラー: 真偽値は対象外
NIL NUM                # エラー: NILは対象外

## 注意
- 入力がStringの場合のみ処理を行う
- パース失敗はエラーではなくNILを返す（停止しない）
- 分数表記（1/3）と小数表記（0.333）の両方に対応"#.to_string(),

        "STR" => r#"# STR - 値を文字列に変換（Stringify）

## 機能
任意の値を人間が読める形式の文字列に変換します。

## 使用法
値 STR
→ 文字列表現を返す

## 使用例
123 STR                # → '123'
1/3 STR                # → '1/3'
TRUE STR               # → 'TRUE'
FALSE STR              # → 'FALSE'
NIL STR                # → 'NIL'
[ 1 2 3 ] STR          # → '1 2 3'

## 「変化なしはエラー」原則
'hello' STR            # エラー: 既に文字列

## NUMとの往復変換
123 STR NUM            # → [ 123 ]（文字列化してパース）
'456' NUM STR          # → '456'（パースして文字列化）

## 注意
- 入力が既にStringの場合はエラー
- ベクタは要素を空白区切りで連結
- 分数は約分された形式で出力"#.to_string(),

        "BOOL" => r#"# BOOL - 真偽値に正規化（Parse/Normalize Boolean）

## 機能
文字列または数値を真偽値に正規化します。

## 使用法
値 BOOL
→ TRUE, FALSE, またはNIL

## 文字列からのパース
'true' BOOL            # → TRUE（大文字小文字無視）
'TRUE' BOOL            # → TRUE
'True' BOOL            # → TRUE
'false' BOOL           # → FALSE
'FALSE' BOOL           # → FALSE
'other' BOOL           # → NIL（パース失敗）
'1' BOOL               # → NIL（'true'/'false'以外はNIL）

## 数値からの正規化（Truthiness判定）
100 BOOL               # → TRUE（0以外はTRUE）
1 BOOL                 # → TRUE
-1 BOOL                # → TRUE
1/2 BOOL               # → TRUE（分数も0以外はTRUE）
0 BOOL                 # → FALSE

## 「変化なしはエラー」原則
TRUE BOOL              # エラー: 既に真偽値
FALSE BOOL             # エラー: 既に真偽値

## エラーケース
NIL BOOL               # エラー: NILは対象外

## 注意
- 文字列は 'true'/'false' のみをパース（大文字小文字無視）
- 数値は Truthiness 判定（0 → FALSE、0以外 → TRUE）
- パース失敗はNILを返す（エラーにしない）"#.to_string(),

        "CHR" => r#"# CHR - 数値をUnicode文字に変換

## 機能
数値（Unicodeコードポイント）を1文字の文字列に変換します。
旧STRが持っていた「数値を文字コードとして解釈する機能」を独立させたものです。

## 使用法
数値 CHR
→ 対応する1文字の文字列

## 使用例
65 CHR                 # → 'A'
97 CHR                 # → 'a'
48 CHR                 # → '0'
10 CHR                 # → '\n'（改行）
12354 CHR              # → 'あ'（ひらがな）
20320 CHR              # → '你'（漢字）

## ASCIIテーブルの主要な値
32 CHR                 # → ' '（スペース）
65 CHR                 # → 'A'
90 CHR                 # → 'Z'
97 CHR                 # → 'a'
122 CHR                # → 'z'

## エラーケース
'A' CHR                # エラー: 文字列は不可
-1 CHR                 # エラー: 負の数は不可
0x110000 CHR           # エラー: Unicodeの範囲外
1/2 CHR                # エラー: 整数のみ

## 文字コードを取得するには
# 文字から数値への逆変換は現在未実装
# CHARSとインデックスを使用

## 注意
- 有効なUnicodeコードポイント: 0〜0x10FFFF
- サロゲートペア範囲（0xD800〜0xDFFF）は無効
- 整数のみ受け付け（分数はエラー）"#.to_string(),

        // ============================================================================
        // 日時操作（BigQuery設計思想: タイムゾーンは変換パラメータ）
        // ============================================================================

        "NOW" => r#"# NOW - 現在時刻取得

## 機能
現在のUnixタイムスタンプを分数として取得します。
これは「絶対時刻」（瞬間）であり、タイムゾーン情報を持ちません。

## 設計思想（BigQuery SQLに準拠）
- タイムスタンプは「瞬間」を表す絶対時刻
- タイムゾーンはデータの一部ではなく、変換時のパラメータ
- 同じ瞬間は全世界で普遍（東京時間でもロンドン時間でもない）

## 使用法
NOW
→ 現在のUnixタイムスタンプ（秒、ミリ秒精度の分数）

## 使用例
NOW                              # → [ 1732531200500/1000 ]
# 内部的には分数（ミリ秒精度）

# 処理時間の計測
NOW                              # 開始
... 何らかの処理 ...
NOW                              # 終了
-                                # 経過時間（秒）

## 注意
- Stackモード (..) はサポートされません
- 戻り値は単なる分数（タイムゾーン情報なし）"#.to_string(),

        "DATETIME" => r#"# DATETIME - 日時ベクタに変換

## 機能
Unixタイムスタンプ（絶対時刻）を、指定したタイムゾーンでの
日付時刻ベクタ [年 月 日 時 分 秒] に変換します。

## 設計思想（BigQuery SQLに準拠）
- タイムゾーンは変換パラメータであり、データの一部ではない
- 「この瞬間は、東京時間で表すと何年何月何日何時？」という変換
- タイムゾーン指定は必須（省略不可）→ 意識を強制

## 使用法
[ タイムスタンプ ] 'タイムゾーン' DATETIME
→ 日付時刻ベクタ [年 月 日 時 分 秒]

## タイムゾーン
- 'LOCAL': ブラウザのローカルタイムゾーン
- （将来: 'UTC', 'Asia/Tokyo' など）

## 使用例
[ 1732531200 ] 'LOCAL' DATETIME
# → [ 2024 11 25 23 0 0 ]（日本時間の場合）

# サブ秒精度がある場合
[ 1732531200500/1000 ] 'LOCAL' DATETIME
# → [ 2024 11 25 23 0 0 1/2 ]

# 年だけ取得
[ 1732531200 ] 'LOCAL' DATETIME [ 0 ] GET
# → [ ... ] [ 2024 ]

## 注意
- タイムゾーン指定は必須（省略するとエラー）
- Stackモード (..) はサポートされません
- 月は1-12、日は1-31、時は0-23"#.to_string(),

        "TIMESTAMP" => r#"# TIMESTAMP - タイムスタンプに変換

## 機能
指定したタイムゾーンでの日付時刻ベクタ [年 月 日 時 分 秒] を
Unixタイムスタンプ（絶対時刻）に変換します。

## 設計思想（BigQuery SQLに準拠）
- タイムゾーンは変換パラメータであり、データの一部ではない
- 「東京時間の2024年11月25日23時は、どの瞬間？」という変換
- タイムゾーン指定は必須（省略不可）→ 意識を強制

## 使用法
[ [ 年 月 日 時 分 秒 ] ] 'タイムゾーン' TIMESTAMP
→ Unixタイムスタンプ（分数）

## タイムゾーン
- 'LOCAL': ブラウザのローカルタイムゾーン
- （将来: 'UTC', 'Asia/Tokyo' など）

## 使用例
[ [ 2024 11 25 23 0 0 ] ] 'LOCAL' TIMESTAMP
# → [ 1732531200 ]（日本時間の場合）

# サブ秒精度を含む
[ [ 2024 11 25 23 0 0 1/2 ] ] 'LOCAL' TIMESTAMP
# → [ 1732531200500/1000 ]

# 日付の比較
[ [ 2024 12 25 0 0 0 ] ] 'LOCAL' TIMESTAMP
[ [ 2024 12 31 0 0 0 ] ] 'LOCAL' TIMESTAMP
<
# → [ TRUE ]（12/25 < 12/31）

## エラーケース
[ [ 2023 13 32 0 0 0 ] ] 'LOCAL' TIMESTAMP
# エラー：実在しない日付

[ [ 2024 2 30 0 0 0 ] ] 'LOCAL' TIMESTAMP
# エラー：2024年2月30日は存在しない

## 注意
- タイムゾーン指定は必須（省略するとエラー）
- Stackモード (..) はサポートされません
- 実在しない日時はエラー（自動補正しない）"#.to_string(),

        // ============================================================================
        // 算術演算
        // ============================================================================

        "+" => r#"# + - 加算

## 機能（StackTopモード）
2つのベクタの要素ごとの加算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に加算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] +
→ 要素ごとに加算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. +
→ 指定個数の要素を加算した結果

## 使用例（StackTopモード）
[ 1 2 3 ] [ 4 5 6 ] +      # → [ 5 7 9 ]  (要素ごと)
[ 1 2 3 ] [ 10 ] +         # → [ 11 12 13 ]  (ブロードキャスト)
[ 5 ] [ 1 2 3 ] +          # → [ 6 7 8 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 1 ] [ 2 ] [ 3 ] [ 3 ] .. +   # → [ 6 ]  (1+2+3)
[ 10 ] [ 5 ] [ 2 ] .. +        # → [ 12 ]  (10+5、デフォルト2個)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[0]との加算）はエラー"#.to_string(),

        "-" => r#"# - - 減算

## 機能（StackTopモード）
2つのベクタの要素ごとの減算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に減算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] -
→ 要素ごとに減算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. -
→ 指定個数の要素を減算した結果

## 使用例（StackTopモード）
[ 5 7 9 ] [ 1 2 3 ] -      # → [ 4 5 6 ]  (要素ごと)
[ 10 20 30 ] [ 5 ] -       # → [ 5 15 25 ]  (ブロードキャスト)
[ 100 ] [ 1 2 3 ] -        # → [ 99 98 97 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 10 ] [ 3 ] [ 2 ] [ 3 ] .. -  # → [ 5 ]  (10-3-2)
[ 100 ] [ 25 ] [ 2 ] .. -      # → [ 75 ]  (100-25)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[0]との減算）はエラー"#.to_string(),

        "*" => r#"# * - 乗算

## 機能（StackTopモード）
2つのベクタの要素ごとの乗算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に乗算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] *
→ 要素ごとに乗算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. *
→ 指定個数の要素を乗算した結果

## 使用例（StackTopモード）
[ 1 2 3 ] [ 4 5 6 ] *      # → [ 4 10 18 ]  (要素ごと)
[ 1 2 3 ] [ 10 ] *         # → [ 10 20 30 ]  (ブロードキャスト)
[ 5 ] [ 2 3 4 ] *          # → [ 10 15 20 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 2 ] [ 3 ] [ 4 ] [ 3 ] .. *   # → [ 24 ]  (2*3*4)
[ 5 ] [ 6 ] [ 2 ] .. *         # → [ 30 ]  (5*6)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[1]との乗算）はエラー"#.to_string(),

        "/" => r#"# / - 除算

## 機能（StackTopモード）
2つのベクタの要素ごとの除算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。
結果は分数として正確に保持されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に除算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] /
→ 要素ごとに除算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. /
→ 指定個数の要素を除算した結果

## 使用例（StackTopモード）
[ 10 20 30 ] [ 2 4 5 ] /   # → [ 5 5 6 ]  (要素ごと)
[ 10 20 30 ] [ 10 ] /      # → [ 1 2 3 ]  (ブロードキャスト)
[ 100 ] [ 2 4 5 ] /        # → [ 50 25 20 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 100 ] [ 2 ] [ 5 ] [ 3 ] .. /  # → [ 10 ]  (100/2/5)
[ 20 ] [ 4 ] [ 2 ] .. /         # → [ 5 ]  (20/4)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 0での除算はエラー
- 演算結果が入力と同じ場合（例：[1]での除算）はエラー"#.to_string(),

        // ============================================================================
        // 比較演算
        // ============================================================================

        "=" => r#"# = - 等価比較

## 機能（StackTopモード）
2つの値を比較し、完全に等しいかどうかを判定します。
あらゆる型の値を比較可能（Number、String、Boolean、Vector、Nil）。

## 機能（Stackモード）
N個の要素を順に比較し、全て等しいかを判定します。

## 使用法
[ value1 ] [ value2 ] =
→ 等しければ [true]、異なれば [false]

## 使用例（StackTopモード）
[ 3 ] [ 3 ] =              # → [ true ]
[ 3 ] [ 5 ] =              # → [ false ]
[ 'hello' ] [ 'hello' ] =  # → [ true ]
[ 1 2 ] [ 1 2 ] =          # → [ true ]  (ベクタ全体を比較)
[ 1 2 ] [ 1 3 ] =          # → [ false ]

## 使用例（Stackモード）
[ 3 ] [ 3 ] [ 3 ] [ 3 ] .. =    # → [ true ]  (全て等しい)
[ 1 ] [ 2 ] [ 1 ] [ 3 ] .. =    # → [ false ] (1≠2)

## 注意
- ベクタ全体を1つの値として比較します
- 要素ごとの比較ではありません"#.to_string(),

        "<" => r#"# < - 小なり比較

## 機能
2つのベクタの要素ごとに「左 < 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] <
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 1 2 3 ] [ 2 2 2 ] <      # → [ true false false ]
[ 1 2 3 ] [ 3 ] <          # → [ true true false ]  (ブロードキャスト)
[ 5 ] [ 1 2 3 4 5 ] <      # → [ false false false false false ]

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        "<=" => r#"# <= - 小なりイコール比較

## 機能
2つのベクタの要素ごとに「左 <= 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] <=
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 1 2 3 ] [ 2 2 2 ] <=     # → [ true true false ]
[ 1 2 3 ] [ 3 ] <=         # → [ true true true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        ">" => r#"# > - 大なり比較

## 機能
2つのベクタの要素ごとに「左 > 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] >
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 3 2 1 ] [ 2 2 2 ] >      # → [ true false false ]
[ 5 4 3 ] [ 3 ] >          # → [ true true false ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        ">=" => r#"# >= - 大なりイコール比較

## 機能
2つのベクタの要素ごとに「左 >= 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] >=
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 3 2 1 ] [ 2 2 2 ] >=     # → [ true true false ]
[ 5 4 3 ] [ 3 ] >=         # → [ true true true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        // ============================================================================
        // 論理演算
        // ============================================================================

        "AND" => r#"# AND - 論理積

## 機能
2つのベクタの要素ごとに論理積（AND）を計算します。
要素数が等しい場合は要素ごとに演算、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] AND
→ 各要素の論理積のベクタ

## 使用例
[ true true false false ] [ true false true false ] AND
# → [ true false false false ]

[ true false true ] [ true ] AND
# → [ true false true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 要素はboolean型である必要があります"#.to_string(),

        "OR" => r#"# OR - 論理和

## 機能
2つのベクタの要素ごとに論理和（OR）を計算します。
要素数が等しい場合は要素ごとに演算、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] OR
→ 各要素の論理和のベクタ

## 使用例
[ true true false false ] [ true false true false ] OR
# → [ true true true false ]

[ true false true ] [ false ] OR
# → [ true false true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 要素はboolean型である必要があります"#.to_string(),

        "NOT" => r#"# NOT - 論理否定

## 機能
ベクタの各要素の論理否定（NOT）を計算します。

## 使用法
[ 要素... ] NOT
→ 各要素を否定したベクタ

## 使用例
[ true false true ] NOT    # → [ false true false ]
[ false ] NOT              # → [ true ]

## 注意
- 要素はboolean型である必要があります"#.to_string(),

        // ============================================================================
        // 制御構造
        // ============================================================================

        ":" => r#"# : - ガード区切り（条件分岐）

## 機能
条件による分岐を実現します。
「条件 : アクション : 条件 : アクション : デフォルト」の形式で使用します。

## 使用法
条件1 : アクション1 : 条件2 : アクション2 : ... : デフォルトアクション

## 動作
- 左から順に条件を評価
- 最初にtrueになった条件のアクションを実行
- すべての条件がfalseの場合、デフォルトアクションを実行

## 使用例
# 値が正か負かゼロかを判定
[ 5 ] [ 0 ] > : 'positive' : [ 5 ] [ 0 ] < : 'negative' : 'zero'
# → 'positive' (5 > 0がtrue)

# 単純なif-else
[ x ] [ 10 ] > : '大きい' : '小さいか等しい'

## 注意
- 条件は真偽値（true/false）を返す式である必要があります
- コロンの数は奇数個になります（条件:アクション:条件:アクション:デフォルト）"#.to_string(),

        // ============================================================================
        // 高階関数
        // ============================================================================

        "MAP" => r#"# MAP - 各要素に関数を適用

## 機能
ベクタまたはスタックの各要素に対して、指定したコードを適用します。

## 使用法（StackTopモード）
[ 要素... ] [ [ code ] ] MAP          # Vector（コード）を直接指定
[ 要素... ] 'WORD' MAP                 # ワード名で指定
→ 各要素にコードを適用した結果のベクタ

## 使用法（Stackモード）
要素... [ 個数 ] [ [ code ] ] .. MAP
→ 指定個数の要素にコードを適用

## 使用例
[ 1 2 3 4 ] [ [ 2 ] * ] MAP
# → [ 2 4 6 8 ]  (各要素を2倍)

[ 1 2 3 ] [ [ 1 ] + ] MAP
# → [ 2 3 4 ]  (各要素に1を加算)

# カスタムワードを使用
[ [ 2 ] * [ 1 ] + ] 'DOUBLE_PLUS_ONE' DEF
[ 1 2 3 ] 'DOUBLE_PLUS_ONE' MAP
# → [ 3 5 7 ]  (各要素を2倍して1を足す)

## 注意
- Vectorをコードとして直接指定可能（Vector Duality）
- ワード名（文字列）での指定も引き続きサポート
- 各要素に対して独立して実行されます"#.to_string(),

        "FILTER" => r#"# FILTER - 条件に合う要素を抽出

## 機能
ベクタの各要素に対して条件コードを適用し、
trueを返した要素のみを残します。

## 使用法
[ 要素... ] [ [ condition ] ] FILTER   # Vector（コード）を直接指定
[ 要素... ] 'WORD' FILTER              # ワード名で指定
→ 条件を満たす要素のみのベクタ

## 使用例
[ 1 2 3 4 5 6 ] [ [ 2 ] MOD [ 0 ] = NOT ] FILTER
# → [ 1 3 5 ]  (奇数のみ抽出)

[ 10 5 20 3 15 ] [ [ 10 ] > ] FILTER
# → [ 20 15 ]  (10より大きい要素)

# カスタムワードを使用
[ [ 5 ] > ] 'IS_LARGE' DEF
[ 1 3 8 2 7 ] 'IS_LARGE' FILTER
# → [ 8 7 ]  (5より大きい要素)

## 注意
- Vectorをコードとして直接指定可能（Vector Duality）
- ワード名（文字列）での指定も引き続きサポート
- 条件コードはtrue/falseを返す必要があります"#.to_string(),

        "FOLD" => r#"# FOLD - 初期値付き畳み込み

## 機能
ベクタまたはスタック上の要素を、初期値から始めて二項演算コードで畳み込み、
単一の結果に集約します。REDUCEと異なり、初期値を明示的に指定できます。

## REDUCEとの違い
- REDUCE: 最初の要素を初期値として使用、空ベクタでエラー
- FOLD: 初期値を明示的に指定、空ベクタでは初期値をそのまま返す

## 畳み込みの順序
左から右へ順番に演算を適用します：
[ a b c ] [init] [ [ op ] ] FOLD = ((init OP a) OP b) OP c

## 使用法（StackTopモード）
[ 要素... ] [ 初期値 ] [ [ code ] ] FOLD   # Vector（コード）を直接指定
[ 要素... ] [ 初期値 ] 'ワード名' FOLD     # ワード名で指定
→ 畳み込んだ結果を単一要素ベクタとして返す

## 使用法（Stackモード）
要素... [ 個数 ] [ 初期値 ] [ [ code ] ] .. FOLD
→ スタック上のN個の要素を初期値から畳み込む

## 使用例
[ 1 2 3 4 ] [ 0 ] [ + ] FOLD     # → [ 10 ]  (0+1+2+3+4)
[ 1 2 3 4 ] [ 1 ] [ * ] FOLD     # → [ 24 ]  (1*1*2*3*4)
[ 1 2 3 ] [ 10 ] [ - ] FOLD      # → [ 4 ]   (10-1-2-3)

# 空ベクタ（NIL）の場合は初期値がそのまま返る
[ ] [ 42 ] [ + ] FOLD            # → [ 42 ]  ([ ] = NIL)

# カスタム演算（Vector Duality）
[ 1 2 3 ] [ 0 ] [ [ 2 ] * + ] FOLD   # → [ 12 ]  (各要素を2倍して加算)

# Stackモード
[1] [2] [3] [3] [0] [ + ] .. FOLD   # → [ 6 ]  (0+1+2+3)

## 畳み込みの動作（詳細）
[ 1 2 3 ] [ 0 ] [ + ] FOLD の処理順序：
1. acc = 0 (初期値)
2. acc = acc + 1 = 1
3. acc = acc + 2 = 3
4. acc = acc + 3 = 6
5. 結果: [ 6 ]

## 注意
- 空ベクタ [ ] はNILとして扱われる
- 空ベクタ（NIL）に対しては初期値をそのまま返す（エラーにならない）
- 単一要素のベクタに対しても正常動作（init OP x を計算）
- 適用するコードは2つの値を受け取り、1つを返す必要がある
- 組み込みワード（+, -, *, /）とカスタムワードの両方が使用可能
- Vectorをコードとして直接指定可能（Vector Duality）"#.to_string(),

        // ============================================================================
        // 入出力
        // ============================================================================

        "PRINT" => r#"# PRINT - 要素を出力

## 機能
スタックトップの要素を出力バッファに書き込みます。
要素はスタックから除去されます。

## 使用法
要素 PRINT
→ 要素を出力し、スタックから削除

## 使用例
[ 42 ] PRINT              # 出力: 42
'Hello' PRINT             # 出力: Hello
[ 1 2 3 ] PRINT           # 出力: [1 2 3]

# 複数の値を出力
[ 1 ] [ 2 ] [ 3 ]
PRINT PRINT PRINT         # 出力: 1 2 3

## 注意
- 出力後、要素はスタックから削除されます
- 出力フォーマットは要素の型によって自動的に決定されます"#.to_string(),

        "SEQ" => r#"# SEQ - 順次再生モード

## 機能
続くPLAYコマンドで、Vector内の要素を順番に再生します。
これはデフォルトモードです。

## 使用法
[ 音1 音2 音3 ] SEQ PLAY
→ 音1 → 音2 → 音3 の順に再生

## 使用例
[ 440 550 660 ] SEQ PLAY           # 3音を順番に
[ 440/2 550/1 660/2 ] SEQ PLAY     # 音長指定付き

## 注意
- SEQはデフォルトモードです
- PLAYの後、モードはSEQにリセットされます"#.to_string(),

        "SIM" => r#"# SIM - 同時再生モード

## 機能
続くPLAYコマンドで、Vector内の要素を同時に再生します。
和音やマルチトラック再生に使用します。

## 使用法
[ 音1 音2 音3 ] SIM PLAY
→ 音1 + 音2 + 音3 を同時に再生

## 使用例
# 和音
[ 440 550 660 ] SIM PLAY           # 3音同時

# マルチトラック
[ 440 550 ] [ 220 275 ] .. SIM PLAY
→ トラック1と2が同時進行

## 注意
- PLAYの後、モードはSEQにリセットされます"#.to_string(),

        "PLAY" => r#"# PLAY - 音声再生

## 機能
スタック上のVectorを音声として再生します。
SEQ/SIMモードとオペレーションターゲットに従って動作します。

## 分数の解釈
- n/d = nHz を dスロット再生
- n = nHz を 1スロット再生
- 0/d = dスロット休符
- NIL = 1スロット休符
- 文字列 = Outputに出力（歌詞）

## 使用例
# 基本
[ 440 550 660 ] PLAY               # 順次再生
[ 440 550 660 ] SIM PLAY           # 和音

# 音長指定
[ 440/2 550/1 660/4 ] PLAY         # 各音の長さを指定

# 休符
[ 440 NIL 550 ] PLAY               # 440 → 休符 → 550
[ 440 0/4 550 ] PLAY               # 440 → 4スロット休符 → 550

# 歌詞
[ 440/2 'き' 550/2 'ら' ] PLAY     # 音と共に歌詞出力

# マルチトラック
[ 440 550 ] [ 220 275 ] .. SIM PLAY

## オペレーションターゲット
- . (デフォルト): スタックトップを再生
- ..: スタック全体を再生

## 注意
- 入力ベクタはスタックから消費されます
- 周波数は正の数値である必要があります
- 20Hz未満、20kHz超の周波数には警告が出力されます"#.to_string(),

        // ============================================================================
        // ワード管理
        // ============================================================================

        "DEF" => r#"# DEF - カスタムワードを定義

## 機能
新しいカスタムワードを定義し、辞書に登録します。
Vector Dualityにより、Vectorをコードとして使用します。

## 使用法
[ [ code ] ] 'NAME' DEF               # 説明なし
[ [ code ] ] 'NAME' '説明' DEF       # 説明あり

## 使用例
# 単純なワード定義
[ [ 2 ] * ] 'DOUBLE' DEF
[ 5 ] DOUBLE                # → [ 10 ]

# 複数の操作を含む定義
[ [ 1 ] + [ 2 ] * ] 'INC_AND_DOUBLE' DEF
[ 5 ] INC_AND_DOUBLE        # → [ 12 ]  ((5+1)*2)

# 説明付きの定義
[ [ 3 ] * ] 'TRIPLE' '値を3倍にする' DEF
'TRIPLE' ?                  # 説明が表示される

## Vector Duality（Vectorの二重性）
Vectorはデータとしてもコードとしても使用できます：
- データとして: [ 1 2 3 ] → 値のコレクション
- コードとして: [ [ 2 ] * ] → DEFやMAPで実行可能

## 注意
- ワード名は自動的に大文字に変換されます
- 組み込みワードは上書きできません
- 既存のカスタムワードは上書きされます"#.to_string(),

        "DEL" => r#"# DEL - カスタムワードを削除

## 機能
辞書からカスタムワードを削除します。

## 使用法
'NAME' DEL
→ 指定したワードを辞書から削除

## 使用例
# ワードを定義して削除
[ '[ 2 ] *' ] 'DOUBLE' DEF
'DOUBLE' DEL                # DOUBLEが削除される

# 削除後は使用不可
[ 5 ] DOUBLE                # エラー: Unknown word

## 注意
- 組み込みワードは削除できません
- 存在しないワードを削除しようとするとエラー
- ワード名は自動的に大文字に変換されます"#.to_string(),

        "?" => r#"# ? - ワード定義を参照

## 機能
ワードの定義や説明をInputエリアに呼び出します。

## 使用法
'NAME' ?
→ ワードの定義をInputエリアに読み込み

## 動作
【組み込みワードの場合】
- 詳細な説明、使用法、使用例が表示されます
- 機能、構文、注意事項などの情報が含まれます

【カスタムワードの場合】
- 定義時の記述がそのまま表示されます
- DEF文として呼び出されるため、再定義が簡単です

## 使用例
'GET' ?                     # GETの詳細な説明が表示される
'DOUBLE' ?                  # DOUBLEの定義が表示される

# カスタムワードの定義を確認して修正
[ [ 2 ] * ] 'DOUBLE' DEF
'DOUBLE' ?                  # [ [ 2 ] * ] 'DOUBLE' DEF
# ↑ Inputエリアに読み込まれるので、編集して再定義可能

## 注意
- ワード名は自動的に大文字に変換されます
- 存在しないワードを参照するとエラー"#.to_string(),

        // ============================================================================
        // 入力支援
        // ============================================================================

        "'" => r#"# ' - シングルクォート挿入

## 機能
Inputエリアにシングルクォート(')を挿入します。
入力支援のための便利機能です。

## 使用法
ボタンをクリックすると、カーソル位置にシングルクォートが挿入されます。

## 使用例
キーボード入力: [  ]  →  ボタン「'」クリック  →  [ '' ]
（カーソルがクォートの間に配置されます）

## 注意
- これは実行可能なワードではなく、入力支援機能です"#.to_string(),

        "FRAME" => r#"# FRAME - 形状指定ブラケット入力

## 機能
形状ベクタを指定して、任意の次元・要素数のブラケット構造をInputエリアに挿入します。
1〜3次元の構造を柔軟に生成できます。

## 使用法
[ dim1 ] FRAME              → dim1 個の1次元ブラケット
[ dim1 dim2 ] FRAME         → dim1 × dim2 の2次元構造
[ dim1 dim2 dim3 ] FRAME    → dim1 × dim2 × dim3 の3次元構造

## 使用例
[ 3 ] FRAME         # → { } { } { }
[ 2 3 ] FRAME       # → { ( ) ( ) ( ) } { ( ) ( ) ( ) }
[ 2 2 3 ] FRAME     # → { ( [ ] [ ] [ ] ) ( [ ] [ ] [ ] ) } { ( [ ] [ ] [ ] ) ( [ ] [ ] [ ] ) }

## 次元構造
- 0次元: スタック（不可視、GUIの枠）
- 1次元: { }
- 2次元: ( )
- 3次元: [ ]（可視限界）

## 注意
- これは入力支援機能です
- 形状ベクタは1〜3要素の正の整数である必要があります
- 各次元の要素数は1〜100の範囲に制限されています"#.to_string(),

        "!" => r#"# ! - 強制実行演算子

## 機能
依存関係のあるカスタムワードの削除（DEL）や再定義（DEF）を許可します。
他のカスタムワードから参照されているワードを操作する際に使用します。

## 使用法
! 'WORDNAME' DEL     # 強制削除
! [ ': ...' ] 'WORDNAME' DEF  # 強制再定義

## 使用例
[ ': [ 2 ] *' ] 'DOUBLE' DEF
[ ': DOUBLE DOUBLE' ] 'QUAD' DEF

'DOUBLE' DEL           # Error: referenced by QUAD
! 'DOUBLE' DEL         # OK（警告付きで削除）

[ ': [ 3 ] *' ] 'DOUBLE' DEF     # Error: referenced by QUAD
! [ ': [ 3 ] *' ] 'DOUBLE' DEF   # OK（警告付きで再定義）

## 注意
- 組み込みワードには効果がありません（常にエラー）
- フラグは次のDEL/DEF実行後に自動リセットされます
- 依存関係のないワードには ! は不要です
- !はDEL/DEFの前に置く必要があります（後置記法のため）"#.to_string(),

        "TIMES" => r#"# TIMES - コードを繰り返し実行

## 機能
指定されたコードを指定回数だけ繰り返し実行します。
ループ処理を簡潔に記述するための制御フローワードです。

## 使用法
[ [ code ] ] [ 回数 ] TIMES     # Vector（コード）を直接指定
'WORDNAME' [ 回数 ] TIMES        # ワード名で指定
→ コードを指定回数実行

## 使用例
# カウンタを3回インクリメント（Vector Duality）
[ 0 ] [ [ 1 ] + ] [ 3 ] TIMES        # → [ 3 ]

# カスタムワードを使用
[ [ 1 ] + ] 'INC' DEF
[ 0 ] 'INC' [ 3 ] TIMES              # → [ 3 ]

# スタックに値を5回プッシュ
[ 0 ] [ [ 1 ] + ] [ 5 ] TIMES        # → [ 5 ]

# 2倍を4回繰り返す（1 * 2^4 = 16）
[ 1 ] [ [ 2 ] * ] [ 4 ] TIMES        # → [ 16 ]

## 注意
- Vectorをコードとして直接指定可能（Vector Duality）
- ワード名（文字列）での指定も引き続きサポート
- ワード名で指定する場合、カスタムワードのみ使用可能（組み込みワードは不可）
- 回数は正の整数である必要があります
- 0回の場合は何も実行されません"#.to_string(),

        "WAIT" => r#"# WAIT - 遅延実行

## 機能
指定したミリ秒後にカスタムワードを実行します。
非同期処理やアニメーションに使用できます。

## 使用法
'WORDNAME' [ ミリ秒 ] WAIT
→ 指定ミリ秒後にワードを実行

## 使用例
# 1秒後にメッセージを出力
[ 'Hello' PRINT ] 'SAY_HELLO' DEF
'SAY_HELLO' [ 1000 ] WAIT      # 1000ms後に実行

# 0.5秒後に値を2倍
[ [ 2 ] * ] 'DOUBLE' DEF
[ 5 ] 'DOUBLE' [ 500 ] WAIT    # 500ms後に [ 10 ]

## 注意
- カスタムワードのみ使用可能（組み込みワードは不可）
- 遅延時間は正の整数（ミリ秒）である必要があります
- 非同期で実行されるため、後続のコードは待機しません"#.to_string(),

        "CSPRNG" => r#"# CSPRNG - 暗号論的疑似乱数生成

## 機能
暗号論的に安全な疑似乱数を分数として生成します。
分母を指定することで、必要な粒度だけを効率的に生成できます。

## 背景：CSPRNGとPRNGの違い
- **PRNG（疑似乱数生成器）**: シード値から決定論的に生成。高速だが予測可能な場合あり
- **CSPRNG（暗号論的疑似乱数生成器）**: OSのエントロピーソースを使用。予測不可能

この実装はWeb Crypto APIを使用し、暗号論的に安全な乱数を提供します。

## 使用法
CSPRNG                    # デフォルト精度（分母2^32）で1個
[ count ] CSPRNG          # デフォルト精度でcount個
[ denom ] [ count ] CSPRNG  # 分母denomで count個

## 使用例：分母指定モード

# サイコロ（分母6で生成、自動約分される）
[ 6 ] [ 1 ] CSPRNG
# → [ 0 ], [ 1/6 ], [ 1/3 ], [ 1/2 ], [ 2/3 ], [ 5/6 ] のいずれか
#   （内部的には0/6〜5/6だが、約分されて表示）

# サイコロを整数に変換（0〜5）
[ 6 ] [ 1 ] CSPRNG [ 6 ] *
# → [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] のいずれか

# サイコロ（1〜6）
[ 6 ] [ 1 ] CSPRNG [ 6 ] * [ 1 ] +
# → [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ] のいずれか

# コイントス（分母2）
[ 2 ] [ 1 ] CSPRNG
# → [ 0 ] または [ 1/2 ]

# パーセント精度で3個
[ 100 ] [ 3 ] CSPRNG
# → [ 23/100 ] [ 1/2 ] [ 89/100 ] など（約分される場合あり）

## 使用例：デフォルト精度

CSPRNG
# → [ 1234567890/4294967296 ]  (32ビット精度)

[ 3 ] CSPRNG
# → 32ビット精度で3個の乱数

## 分母指定の効率性

分母が小さいほど：
- 結果の分数も小さくなる（約分後）
- 後続の演算（*, +, FLOORなど）が高速
- メモリ使用量も削減

## 技術詳細
- 64ビット余裕を持たせたモジュロ方式（バイアス < 2^-64）
- エントロピーソース: Web Crypto API (crypto.getRandomValues)
- 結果は自動的に既約分数に約分される

## 注意
- Stackモード (..) はサポートされません
- 分母・個数は正の整数である必要があります
- 分数や非整数がスタックにある場合は無視され、デフォルト動作"#.to_string(),

        "HASH" => r#"# HASH - 分数ハッシュ関数

## 機能
任意のAjisai値を決定論的にハッシュ化し、[0, 1)範囲の分数として返します。
分数システムを活用した効率的かつ強力なハッシュアルゴリズムを実装しています。

## 特徴
- **決定論的**: 同じ入力は常に同じハッシュを生成
- **正規形認識**: 1/2と2/4は同じ分数なので同じハッシュ
- **分数出力**: ハッシュ値は [0, 1) の範囲の分数として返される
- **可変長出力**: 32ビットから1024ビットまで指定可能

## 使用法
値 HASH                    # デフォルト256ビット
[ bits ] 値 HASH           # 指定ビット数で出力

## 使用例

# 文字列のハッシュ
'hello' HASH
# → [ 12345.../115792089... ]  (256ビット)

# ベクタのハッシュ
[ 1 2 3 ] HASH
# → [ ... ]

# 分数のハッシュ（正規形を使用）
[ 1/2 ] HASH
[ 2/4 ] HASH
# → 両方同じ結果（1/2と2/4は同値）

# ビット数を指定
[ 128 ] 'hello' HASH
# → 128ビットハッシュ（分母が2^128）

[ 512 ] 'hello' HASH
# → 512ビットハッシュ

# 真偽値のハッシュ
[ TRUE ] HASH
[ FALSE ] HASH
# → 異なるハッシュ

# ネストしたベクタ
[ [ 1 2 ] [ 3 4 ] ] HASH
# → ネスト構造も含めてハッシュ

## ハッシュの用途

# データ整合性チェック
[ 'データ' ] HASH 'ORIGINAL_HASH' DEF
# ... 後で検証
[ 'データ' ] HASH ORIGINAL_HASH =
# → [ TRUE ] なら改ざんなし

# 一意識別子の生成
'ユーザーID_タイムスタンプ' HASH

# ハッシュテーブルのキー生成
[ 128 ] 'キー' HASH [ 1000 ] * FLOOR
# → 0-999のバケットインデックス

## アルゴリズム詳細

### 多項式モジュラーハッシュ
1. 入力値を正規バイト列にシリアライズ
2. 3つの大きな素数（約2^127）で多項式評価
3. 結果を混合してビット拡散
4. 分数（hash / 2^bits）として返す

### なぜ分数が効率的か
- **正規形の活用**: Fraction::new()は自動約分するため、
  同値な分数（1/2 = 2/4）は必ず同じバイト列に
- **任意精度**: BigIntを使うため、どんな大きな値でもハッシュ可能
- **統合性**: 結果が分数なので、他の数学演算とシームレスに連携

## 注意
- Stackモード (..) はサポートされません
- ビット数は32〜1024の範囲で指定
- 暗号的用途（パスワードハッシュなど）には専用アルゴリズムを推奨"#.to_string(),

        _ => {
            // 既存の定義情報にフォールバック
            let definitions = get_builtin_definitions();
            for (word_name, description, category) in definitions {
                if word_name == name {
                    return format!("# {} - {}\n\nCategory: {}\n\n## 説明\n{}\n\n詳細な説明は未実装です。",
                        name, description, category, description);
                }
            }
            format!("ワード '{}' の詳細情報はありません。", name)
        }
    }.to_string()
}
