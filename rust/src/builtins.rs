// rust/src/builtins.rs

use std::collections::{HashMap, HashSet};
use crate::types::WordDefinition;

pub fn register_builtins(dictionary: &mut HashMap<String, WordDefinition>) {
    for (name, description, _) in get_builtin_definitions() {
        dictionary.insert(name.to_string(), WordDefinition {
            lines: vec![],
            is_builtin: true,
            description: Some(description.to_string()),
            dependencies: HashSet::new(),
            original_source: None,
        });
    }
}

pub fn get_builtin_definitions() -> Vec<(&'static str, &'static str, &'static str)> {
    vec![
        // 操作対象指定
        (".", "操作対象をスタックトップに設定（デフォルト）｜. + → スタックトップに加算", "Target"),
        ("..", "操作対象をスタック全体に設定｜.. + [ 3 ] → スタック全要素に3を加算", "Target"),

        // 入力支援
        ("'", "シングルクォートを入力｜' → '", "Input Helper"),
        ("[ ]", "空のベクタ括弧を入力｜[ ] → [ ]", "Input Helper"),

        // 位置指定操作(0オリジン)
        ("GET", "指定位置の要素を取得（0オリジン）｜[ 10 20 30 ] [ 0 ] GET → [ 10 20 30 ] [ 10 ]", "Position"),
        ("INSERT", "指定位置に要素を挿入｜[ 1 3 ] [ 1 ] [ 2 ] INSERT → [ 1 2 3 ]", "Position"),
        ("REPLACE", "指定位置の要素を置換｜[ 1 2 3 ] [ 0 ] [ 9 ] REPLACE → [ 9 2 3 ]", "Position"),
        ("REMOVE", "指定位置の要素を削除｜[ 1 2 3 ] [ 0 ] REMOVE → [ 2 3 ]", "Position"),

        // 量指定操作(1オリジン)
        ("LENGTH", "ベクタの長さを取得｜[ 1 2 3 4 5 ] LENGTH → [ 1 2 3 4 5 ] [ 5 ]", "Quantity"),
        ("TAKE", "先頭または末尾からN個の要素を取得｜[ 1 2 3 4 5 ] [ 3 ] TAKE → [ 1 2 3 ]", "Quantity"),

        // Vector構造操作
        ("SPLIT", "ベクタを指定サイズで分割｜[ 1 2 3 4 5 6 ] [ 2 ] [ 3 ] SPLIT → [ 1 2 ] [ 3 4 5 ] [ 6 ]", "Vector"),
        ("CONCAT", "ベクタを連結｜[ 1 2 ] [ 3 4 ] CONCAT → [ 1 2 3 4 ]", "Vector"),
        ("REVERSE", "ベクタの要素を反転｜[ 1 2 3 ] REVERSE → [ 3 2 1 ]", "Vector"),
        ("LEVEL", "ネストされたベクタを平坦化｜[ 1 [ 2 3 ] 4 ] LEVEL → [ 1 2 3 4 ]", "Vector"),
        ("RANGE", "数値範囲を生成｜[ 0 ] [ 5 ] RANGE → [ 0 ] [ 5 ] [ 0 1 2 3 4 5 ]", "Vector"),

        // テンソル形状操作
        ("SHAPE", "テンソルの形状を取得｜[ [ 1 2 ] [ 3 4 ] ] SHAPE → [ [ 1 2 ] [ 3 4 ] ] [ 2 2 ]", "Tensor"),
        ("RANK", "テンソルの次元数を取得｜[ [ 1 2 ] [ 3 4 ] ] RANK → [ [ 1 2 ] [ 3 4 ] ] [ 2 ]", "Tensor"),
        ("RESHAPE", "テンソルの形状を変更｜[ 1 2 3 4 ] [ 2 2 ] RESHAPE → [ [ 1 2 ] [ 3 4 ] ]", "Tensor"),
        ("TRANSPOSE", "2次元テンソルの転置｜[ [ 1 2 ] [ 3 4 ] ] TRANSPOSE → [ [ 1 3 ] [ 2 4 ] ]", "Tensor"),

        // 型変換
        ("STR", "任意の型を文字列に変換｜[ 42 ] STR → [ '42' ], [ TRUE ] STR → [ 'TRUE' ]", "Type Conversion"),
        ("NUM", "文字列または真偽値を数値に変換｜[ '42' ] NUM → [ 42 ], [ TRUE ] NUM → [ 1 ]", "Type Conversion"),
        ("BOOL", "文字列または数値を真偽値に変換｜[ 'TRUE' ] BOOL → [ TRUE ], [ '1' ] BOOL → [ TRUE ], [ 1 ] BOOL → [ TRUE ]", "Type Conversion"),
        ("NIL", "文字列をNilに変換｜[ 'nil' ] NIL → [ nil ]", "Type Conversion"),
        ("CHARS", "文字列を文字ベクタに分解｜[ 'hello' ] CHARS → [ 'h' 'e' 'l' 'l' 'o' ]", "Type Conversion"),
        ("JOIN", "文字列ベクタを連結｜[ 'h' 'e' 'l' 'l' 'o' ] JOIN → [ 'hello' ]", "Type Conversion"),
        ("NOW", "現在のUnixタイムスタンプを取得｜NOW → [ 1732531200500/1000 ]（ミリ秒精度）", "DateTime"),
        ("DATETIME", "タイムスタンプを日付時刻Vectorに変換｜[ 1732531200 ] 'LOCAL' DATETIME → [ [ 2024 11 25 14 0 0 ] ]", "DateTime"),
        ("TIMESTAMP", "日付時刻Vectorをタイムスタンプに変換｜[ [ 2024 11 25 14 0 0 ] ] 'LOCAL' TIMESTAMP → [ 1732531200 ]", "DateTime"),

        // 算術演算
        ("+", "要素ごとの加算または集約｜[ 1 2 ] [ 3 4 ] + → [ 4 6 ]", "Arithmetic"),
        ("-", "要素ごとの減算または集約｜[ 5 3 ] [ 2 1 ] - → [ 3 2 ]", "Arithmetic"),
        ("*", "要素ごとの乗算または集約｜[ 2 3 ] [ 4 5 ] * → [ 8 15 ]", "Arithmetic"),
        ("/", "要素ごとの除算または集約｜[ 10 20 ] [ 2 4 ] / → [ 5 5 ]", "Arithmetic"),

        // 比較演算
        ("=", "ベクタが等しいか判定｜[ 1 2 ] [ 1 2 ] = → [ 1 ]", "Comparison"),
        ("<", "ベクタが小さいか判定｜[ 1 2 ] [ 2 3 ] < → [ 1 ]", "Comparison"),
        ("<=", "ベクタが小さいまたは等しいか判定｜[ 1 2 ] [ 1 2 ] <= → [ 1 ]", "Comparison"),
        (">", "ベクタが大きいか判定｜[ 3 4 ] [ 2 3 ] > → [ 1 ]", "Comparison"),
        (">=", "ベクタが大きいまたは等しいか判定｜[ 2 3 ] [ 2 3 ] >= → [ 1 ]", "Comparison"),

        // 論理演算
        ("AND", "ベクタの論理積｜[ 1 0 ] [ 1 1 ] AND → [ 1 0 ]", "Logic"),
        ("OR", "ベクタの論理和｜[ 1 0 ] [ 0 0 ] OR → [ 1 0 ]", "Logic"),
        ("NOT", "ベクタの論理否定｜[ 1 0 ] NOT → [ 0 1 ]", "Logic"),

        // 制御構造(ガード)
        (":", "条件分岐のガード区切り｜条件 : 処理 : 条件 : 処理 : デフォルト処理", "Control"),

        // 高階関数
        ("MAP", "各要素にワードを適用｜[ 1 2 3 ] '2倍' MAP → [ 2 4 6 ]", "Higher-Order"),
        ("FILTER", "条件に合う要素を抽出｜[ 1 2 3 4 ] '偶数?' FILTER → [ 2 4 ]", "Higher-Order"),
        ("COUNT", "条件に合う要素を数える｜[ 1 2 3 4 5 ] '[ 2 ] >' COUNT → [ 1 2 3 4 5 ] [ 3 ]", "Higher-Order"),
        ("REDUCE", "二項演算で畳み込み｜[ 1 2 3 4 ] '+' REDUCE → [ 10 ]", "Higher-Order"),
        ("FOLD", "初期値付き畳み込み｜[ 1 2 3 4 ] [ 0 ] '+' FOLD → [ 10 ]", "Higher-Order"),
        ("SCAN", "中間結果を保持する畳み込み｜[ 1 2 3 4 ] [ 0 ] '+' SCAN → [ 1 3 6 10 ]", "Higher-Order"),
        ("UNFOLD", "状態からベクタ生成｜[ 1 ] 'GEN' UNFOLD → [ ... ]", "Higher-Order"),

        // 入出力
        ("PRINT", "スタックトップを出力して削除｜[ 42 ] PRINT → （42を出力）", "I/O"),

        // カスタムワード管理
        ("DEF", "カスタムワードを定義｜( [ 2 ] * ) '2倍' DEF", "Word Management"),
        ("DEL", "カスタムワードを削除｜'不要なワード' DEL", "Word Management"),
        ("?", "ワード定義を表示｜'2倍' ?", "Word Management"),

        // 制御フロー（TIMES/WAIT）
        ("TIMES", "ワードをN回繰り返し実行｜'処理' [ 5 ] TIMES", "Control Flow"),
        ("WAIT", "指定ミリ秒後にワードを実行｜'処理' [ 1000 ] WAIT", "Control Flow"),
        ("!", "強制実行フラグ｜依存のあるワードのDEL/DEFを許可｜! 'WORD' DEL", "Control Flow"),

        // ソートアルゴリズム
        ("FRACTIONSORT", "分数専用高速ソート｜[ 1/2 1/3 2/3 ] FRACTIONSORT → [ 1/3 1/2 2/3 ]", "Sort"),
    ]
}

pub fn get_builtin_detail(name: &str) -> String {
    match name {
        // ============================================================================
        // 操作対象指定
        // ============================================================================

        "." => r#"# . - スタックトップ指定

## 機能
操作対象をスタックトップ（最上位のベクタ）に設定します。
デフォルトの動作モードなので、通常は明示的な指定は不要です。

## 使用法
. WORD
→ 次のワードをスタックトップに対して実行

## 使用例
[ 1 2 3 ] . LENGTH     # → [ 1 2 3 ] [ 3 ]
[ 1 2 3 ] LENGTH       # 同じ結果（デフォルト）

## 注意
- これはデフォルトモードなので、通常は省略可能です
- ワード実行後、自動的にこのモードにリセットされます"#.to_string(),

        ".." => r#"# .. - スタック全体指定

## 機能
操作対象をスタック全体に設定します。
多くの組み込みワードがスタックモードに対応しています。

## 使用法
.. WORD
→ 次のワードをスタック全体に対して実行

## 使用例
a b c [ 1 ] .. GET      # → a b c [ b ]
（スタック全体から1番目を取得）

1 2 3 4 5 .. LENGTH     # → 1 2 3 4 5 [ 5 ]
（スタックの要素数を取得）

a b c .. REVERSE        # → c b a
（スタック全体を反転）

## 対応ワード
GET, INSERT, REPLACE, REMOVE, LENGTH, TAKE, SPLIT,
CONCAT, REVERSE, LEVEL, +, -, *, /, MAP など

## 注意
- ワード実行後、自動的にスタックトップモード(.)にリセットされます"#.to_string(),

        // ============================================================================
        // 位置指定操作（0オリジン）
        // ============================================================================

        "GET" => r#"# GET - 指定位置の要素を取得

## 機能
ベクタまたはスタックから、指定した位置（0オリジン）の要素を取得します。
負のインデックスを使用すると、末尾から数えて要素を取得できます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] GET
→ 元のベクタを保持し、取得した要素を新しいベクタとしてプッシュ

## 使用法（Stackモード）
要素... [ インデックス ] .. GET
→ スタック全体から指定位置の要素を取得

## 使用例
[ 10 20 30 ] [ 0 ] GET    # → [ 10 20 30 ] [ 10 ]  (0番目=最初の要素)
[ 10 20 30 ] [ 1 ] GET    # → [ 10 20 30 ] [ 20 ]  (1番目=2番目の要素)
[ 10 20 30 ] [ -1 ] GET   # → [ 10 20 30 ] [ 30 ]  (-1=末尾の要素)
[ 10 20 30 ] [ -2 ] GET   # → [ 10 20 30 ] [ 20 ]  (-2=末尾から2番目)

a b c [ 1 ] .. GET     # → a b c [ b ]  (スタックの1番目を取得)

## 注意
- インデックスが範囲外の場合はエラー
- 空のベクタ/スタックに対する操作はエラー"#.to_string(),

        "INSERT" => r#"# INSERT - 指定位置に要素を挿入

## 機能
ベクタまたはスタックの指定位置（0オリジン）に要素を挿入します。
負のインデックスを使用すると、末尾から数えた位置に挿入できます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] [ 挿入する要素 ] INSERT
→ 指定位置に要素を挿入した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス ] 挿入する要素 .. INSERT
→ スタックの指定位置に要素を挿入

## 使用例
[ 1 3 ] [ 1 ] [ 2 ] INSERT        # → [ 1 2 3 ]  (1番目の位置に2を挿入)
[ a c ] [ 0 ] [ b ] INSERT        # → [ b a c ]  (0番目=先頭に挿入)
[ 1 2 3 ] [ -1 ] [ 9 ] INSERT     # → [ 1 2 9 3 ]  (末尾の要素の前に挿入)
[ 1 2 3 ] [ 3 ] [ 4 ] INSERT      # → [ 1 2 3 4 ]  (末尾への追加も可能)

a c [ 1 ] b .. INSERT          # → a b c  (スタックの1番目にbを挿入)

## 注意
- 単一要素ベクタは自動的にアンラップされます
- 負のインデックスは要素の位置を指します（-1=末尾の要素の位置）"#.to_string(),

        "REPLACE" => r#"# REPLACE - 指定位置の要素を置換

## 機能
ベクタまたはスタックの指定位置（0オリジン）の要素を新しい要素で置き換えます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] [ 新しい要素 ] REPLACE
→ 指定位置の要素を置換した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス ] 新しい要素 .. REPLACE
→ スタックの指定位置の要素を置換

## 使用例
[ 1 2 3 ] [ 0 ] [ 9 ] REPLACE    # → [ 9 2 3 ]  (0番目=最初の要素を9に)
[ 1 2 3 ] [ 1 ] [ 5 ] REPLACE    # → [ 1 5 3 ]  (1番目=2番目の要素を5に)
[ 1 2 3 ] [ -1 ] [ 9 ] REPLACE   # → [ 1 2 9 ]  (-1=末尾を9に)

a b c [ 1 ] X .. REPLACE      # → a X c  (スタックの1番目をXに)

## 注意
- インデックスが範囲外の場合はエラー
- 単一要素ベクタは自動的にアンラップされます"#.to_string(),

        "REMOVE" => r#"# REMOVE - 指定位置の要素を削除

## 機能
ベクタまたはスタックの指定位置（0オリジン）の要素を削除します。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] REMOVE
→ 指定位置の要素を削除した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス ] .. REMOVE
→ スタックの指定位置の要素を削除

## 使用例
[ 1 2 3 ] [ 0 ] REMOVE      # → [ 2 3 ]  (0番目=最初の要素を削除)
[ 1 2 3 ] [ 1 ] REMOVE      # → [ 1 3 ]  (1番目=2番目の要素を削除)
[ 1 2 3 ] [ -1 ] REMOVE     # → [ 1 2 ]  (-1=末尾を削除)
[ 1 2 3 4 ] [ -2 ] REMOVE   # → [ 1 2 4 ]  (-2=末尾から2番目を削除)

a b c [ 1 ] .. REMOVE    # → a c  (スタックの1番目を削除)

## 注意
- インデックスが範囲外の場合はエラー"#.to_string(),

        // ============================================================================
        // 量指定操作（1オリジン）
        // ============================================================================

        "LENGTH" => r#"# LENGTH - 要素数を取得

## 機能
ベクタまたはスタック全体の要素数を取得します。

## 使用法（StackTopモード）
[ 要素... ] LENGTH
→ 元のベクタを保持し、要素数を新しいベクタとしてプッシュ

## 使用法（Stackモード）
要素... .. LENGTH
→ スタック全体の要素数をプッシュ

## 使用例
[ 1 2 3 4 5 ] LENGTH    # → [ 1 2 3 4 5 ] [ 5 ]  (5個の要素)
[ ] LENGTH              # → [ ] [ 0 ]  (空ベクタは0)
[ 42 ] LENGTH           # → [ 42 ] [ 1 ]  (1個の要素)

a b c d .. LENGTH    # → a b c d [ 4 ]  (スタックに4個)

## 注意
- StackTopモードでは対象がベクタでない場合はエラー"#.to_string(),

        "TAKE" => r#"# TAKE - 先頭または末尾から指定数の要素を取得

## 機能
正の数を指定すると先頭から、負の数を指定すると末尾から、
指定した個数の要素を取得します。

## 使用法（StackTopモード）
[ 要素... ] [ 個数 ] TAKE
→ 取得した要素からなる新しいベクタを返す

## 使用法（Stackモード）
要素... [ 個数 ] .. TAKE
→ スタックを指定個数の要素に切り詰める

## 使用例
[ 1 2 3 4 5 ] [ 3 ] TAKE     # → [ 1 2 3 ]  (先頭から3個)
[ 1 2 3 4 5 ] [ -2 ] TAKE    # → [ 4 5 ]  (末尾から2個)
[ 1 2 3 4 5 ] [ 1 ] TAKE     # → [ 1 ]  (先頭1個)

a b c d e [ 3 ] .. TAKE   # → a b c  (先頭3個だけ残す)
a b c d e [ -2 ] .. TAKE  # → d e  (末尾2個だけ残す)

## 注意
- 指定個数が要素数を超える場合はエラー
- 0を指定した場合の動作は未定義"#.to_string(),

        "SPLIT" => r#"# SPLIT - 指定サイズで分割

## 機能
ベクタまたはスタックを、指定したサイズに分割します。
複数のサイズを指定でき、余りは最後のベクタに含まれます。

## 使用法（StackTopモード）
[ 要素... ] [ サイズ1 ] [ サイズ2 ] ... SPLIT
→ 分割された複数のベクタをプッシュ

## 使用法（Stackモード）
要素... [ サイズ1 ] [ サイズ2 ] ... .. SPLIT
→ スタックを分割し、結果をベクタとしてプッシュ

## 使用例
[ 1 2 3 4 5 6 ] [ 2 ] [ 3 ] [ 1 ] SPLIT
# → [ 1 2 ] [ 3 4 5 ] [ 6 ]  (2個、3個、1個に分割)

[ 1 2 3 4 5 6 ] [ 2 ] [ 2 ] SPLIT
# → [ 1 2 ] [ 3 4 ] [ 5 6 ]  (余りも自動的にベクタに)

a b c d e [ 2 ] [ 1 ] .. SPLIT
# → [ a b ] [ c ] [ d e ]  (スタックを分割)

## 注意
- サイズの合計が要素数を超える場合はエラー
- 最低1つのサイズ指定が必要"#.to_string(),

        // ============================================================================
        // ベクタ構造操作
        // ============================================================================

        "CONCAT" => r#"# CONCAT - ベクタを連結

## 機能
複数のベクタを1つに連結します。
デフォルトは2個、個数を指定可能。負数で逆順連結。

## 使用法（StackTopモード）
vec1 vec2 CONCAT              # 2個を連結（デフォルト）
vec1 vec2 vec3 [ 3 ] CONCAT   # 3個を連結
vec1 vec2 vec3 [ -3 ] CONCAT  # 3個を逆順で連結

## 使用法（Stackモード）
要素... .. CONCAT          # スタック全体を連結
要素... [ 個数 ] .. CONCAT # 指定個数を連結

## 使用例
[ a ] [ b ] CONCAT                # → [ a b ]  (デフォルト2個)
[ a ] [ b ] [ c ] [ 3 ] CONCAT    # → [ a b c ]  (3個を連結)
[ a ] [ b ] [ c ] [ -3 ] CONCAT   # → [ c b a ]  (逆順)
[ 1 ] [ 2 3 ] [ 4 ] [ 3 ] CONCAT  # → [ 1 2 3 4 ]

a b c .. CONCAT                # → [ a b c ]  (全体を連結)
a b c [ 2 ] .. CONCAT          # → a [ b c ]  (2個だけ連結)

## 注意
- ベクタでない要素も単独要素として含まれます
- 最初のベクタの括弧タイプが結果に適用されます"#.to_string(),

        "REVERSE" => r#"# REVERSE - 要素の順序を反転

## 機能
ベクタまたはスタックの要素順序を反転します。
「変化なしはエラー」原則により、要素が2個未満や回文の場合はエラー。

## 使用法（StackTopモード）
[ 要素... ] REVERSE
→ 要素順を反転した新しいベクタを返す

## 使用法（Stackモード）
要素... .. REVERSE
→ スタックの要素順を反転

## 使用例
[ a b c ] REVERSE      # → [ c b a ]
[ 1 2 3 4 ] REVERSE    # → [ 4 3 2 1 ]

a b c .. REVERSE    # → c b a

## エラーケース
[ 1 ] REVERSE          # エラー：1要素のみ（変化なし）
[ a b a ] REVERSE      # エラー：回文（変化なし）
[ ] REVERSE            # エラー：空ベクタ（変化なし）

## 注意
- 変化が生じない場合は必ずエラーになります"#.to_string(),

        "LEVEL" => r#"# LEVEL - ネストされたベクタを平坦化

## 機能
ネストされたベクタをすべて展開し、1次元のベクタにします。
「変化なしはエラー」原則により、すでに平坦な場合はエラー。

## 使用法（StackTopモード）
[ ネストされた要素... ] LEVEL
→ すべてのネストを解消した平坦なベクタを返す

## 使用法（Stackモード）
要素... .. LEVEL
→ スタック内のベクタをすべて展開

## 使用例
[ [ a b ] [ c ] ] LEVEL        # → [ a b c ]
[ [ 1 ] [ [ 2 ] 3 ] ] LEVEL    # → [ 1 2 3 ]  (再帰的に展開)
[ [ a ] b [ c d ] ] LEVEL      # → [ a b c d ]

[ a ] [ b ] [ c ] .. LEVEL  # → a b c  (ベクタを展開)

## エラーケース
[ a b c ] LEVEL                # エラー：すでに平坦（変化なし）
a b c .. LEVEL              # エラー：ベクタがない（変化なし）

## 注意
- すべてのネストレベルが再帰的に展開されます"#.to_string(),

        "RANGE" => r#"# RANGE - 数値範囲を生成

## 機能
startからendまでの整数の範囲（等差数列）を生成します。
オプションでstep（増分）を指定可能です。

## 使用法（StackTopモード）
[ start ] [ end ] RANGE
→ 元の引数を保持し、範囲ベクタを追加

[ start ] [ end ] [ step ] RANGE
→ 元の引数を保持し、step間隔の範囲ベクタを追加

## 使用法（Stackモード）
start end .. RANGE
→ 範囲ベクタを生成

start end step .. RANGE
→ step間隔の範囲ベクタを生成

## 使用例
[ 0 ] [ 5 ] RANGE              # → [ 0 ] [ 5 ] [ 0 1 2 3 4 5 ]
[ 1 ] [ 10 ] RANGE             # → [ 1 ] [ 10 ] [ 1 2 3 4 5 6 7 8 9 10 ]
[ 0 ] [ 10 ] [ 2 ] RANGE       # → [ 0 ] [ 10 ] [ 2 ] [ 0 2 4 6 8 10 ]  (偶数)
[ 10 ] [ 0 ] [ -2 ] RANGE      # → [ 10 ] [ 0 ] [ -2 ] [ 10 8 6 4 2 0 ]  (降順)
[ 5 ] [ 5 ] RANGE              # → [ 5 ] [ 5 ] [ 5 ]  (単一要素)

0 5 .. RANGE                # → [ 0 1 2 3 4 5 ]
0 10 2 .. RANGE             # → [ 0 2 4 6 8 10 ]

## 活用例
# MAPと組み合わせてインデックス付き処理
[ 0 ] [ 4 ] RANGE '処理' MAP

# LENGTHと組み合わせて要素数分のループ
[ data ] LENGTH [ 1 ] - [ 0 ] SWAP RANGE

## エラーケース
[ 0 ] [ 10 ] [ 0 ] RANGE       # エラー：stepが0
[ 0 ] [ 10 ] [ -1 ] RANGE      # エラー：無限シーケンス（start < end だが step < 0）
[ 10 ] [ 0 ] [ 1 ] RANGE       # エラー：無限シーケンス（start > end だが step > 0）

## 注意
- endの値は範囲に含まれます（inclusive）
- stepのデフォルトは自動判定（start <= end なら 1、そうでなければ -1）
- 整数のみサポート"#.to_string(),

        // ============================================================================
        // 型変換
        // ============================================================================

        "STR" => r#"# STR - 文字列に変換

## 機能
任意の型を文字列表現に変換します。
同型変換（String → String）はエラーとなります。

## 使用法
[ value ] STR
→ 文字列に変換された値

## 使用例
[ 42 ] STR                       # → [ '42' ]
[ 1/3 ] STR                      # → [ '1/3' ]
[ TRUE ] STR                     # → [ 'TRUE' ]
[ FALSE ] STR                    # → [ 'FALSE' ]
[ nil ] STR                      # → [ 'nil' ]
[ [ 1 2 3 ] ] STR                # → [ '1 2 3' ]

## エラーケース
[ 'text' ] STR                   # エラー：同型変換（String → String）

## 注意
- StackTopモードのみサポート
- ベクトルはスペース区切りで平坦化されます"#.to_string(),

        "NUM" => r#"# NUM - 数値に変換

## 機能
文字列または真偽値を数値に変換します。
文字列の場合、パース失敗時はエラーとなります。

## 使用法
[ 'string' ] NUM
→ 数値に変換された値

[ boolean ] NUM
→ 数値に変換された値（TRUE → 1、FALSE → 0）

## 使用例
[ '42' ] NUM                     # → [ 42 ]
[ '1/3' ] NUM                    # → [ 1/3 ]
[ '3.14' ] NUM                   # → [ 157/50 ]（分数として正確に）
[ '1.5e2' ] NUM                  # → [ 150 ]
[ TRUE ] NUM                     # → [ 1 ]
[ FALSE ] NUM                    # → [ 0 ]

## エラーケース
[ 'hello' ] NUM                  # エラー：数値にパース不可
[ 42 ] NUM                       # エラー：同型変換（Number → Number）
[ nil ] NUM                      # エラー：Nilは数値に変換不可

## 注意
- String型またはBoolean型を受け付けます
- 小数は分数に変換されます（丸め誤差なし）
- 真偽値はTRUE → 1、FALSE → 0に変換されます（分数として1/1、0/1）"#.to_string(),

        "BOOL" => r#"# BOOL - 真偽値に変換

## 機能
文字列または数値を真偽値に変換します。
文字列の場合、"TRUE"/"FALSE"、"1"/"0"、"真"/"偽"を受け付けます。
数値の場合、1または0のみを受け付けます。

## 使用法
[ 'string' ] BOOL
→ 真偽値に変換された値

[ number ] BOOL
→ 真偽値に変換された値（1 → TRUE、0 → FALSE）

## 使用例
[ 'TRUE' ] BOOL                  # → [ TRUE ]
[ 'FALSE' ] BOOL                 # → [ FALSE ]
[ 'true' ] BOOL                  # → [ TRUE ]（大小文字無視）
[ 'false' ] BOOL                 # → [ FALSE ]
[ '1' ] BOOL                     # → [ TRUE ]
[ '0' ] BOOL                     # → [ FALSE ]
[ '真' ] BOOL                    # → [ TRUE ]
[ '偽' ] BOOL                    # → [ FALSE ]
[ 1 ] BOOL                       # → [ TRUE ]
[ 0 ] BOOL                       # → [ FALSE ]

## エラーケース
[ 'hello' ] BOOL                 # エラー：真偽値として認識不可
[ 2 ] BOOL                       # エラー：1または0以外の数値
[ TRUE ] BOOL                    # エラー：同型変換（Boolean → Boolean）
[ nil ] BOOL                     # エラー：Nilは真偽値に変換不可

## 注意
- String型またはNumber型を受け付けます
- 文字列の'TRUE'/'FALSE'は大文字小文字を区別しません
- 数値は1（1/1）または0（0/1）のみ有効です"#.to_string(),

        "NIL" => r#"# NIL - Nilに変換

## 機能
文字列をNilにパースします。
"nil"のみ受け付けます（大小文字無視）。

## 使用法
[ 'string' ] NIL
→ Nilに変換された値

## 使用例
[ 'nil' ] NIL                    # → [ nil ]
[ 'NIL' ] NIL                    # → [ nil ]（大小文字無視）
[ 'Nil' ] NIL                    # → [ nil ]

## エラーケース
[ 'hello' ] NIL                  # エラー：'nil'でない文字列
[ '0' ] NIL                      # エラー：'nil'でない文字列
[ TRUE ] NIL                     # エラー：Booleanは変換不可
[ 42 ] NIL                       # エラー：Numberは変換不可
[ nil ] NIL                      # エラー：同型変換（Nil → Nil）

## 注意
- String型のみ受け付けます
- 大文字小文字は区別しません
- Boolean型、Number型、Nil型への適用はエラーになります"#.to_string(),

        "CHARS" => r#"# CHARS - 文字列を文字ベクタに分解

## 機能
文字列を1文字ずつの文字列ベクタに分解します。
UTF-8マルチバイト文字（日本語など）も正しく処理されます。

## 使用法（StackTopモード）
[ 'string' ] CHARS
→ 文字ベクタ

## 使用法（Stackモード）
str1 str2 ... .. CHARS
→ 各文字列を文字ベクタに変換

## 使用例
[ 'hello' ] CHARS                # → [ 'h' 'e' 'l' 'l' 'o' ]
[ '日本語' ] CHARS               # → [ '日' '本' '語' ]
[ 'a' ] CHARS                    # → [ 'a' ]

'abc' 'xyz' .. CHARS             # → [ 'a' 'b' 'c' ] [ 'x' 'y' 'z' ]

## 活用例（既存ワードとの組み合わせ）
# 文字列を反転
[ 'hello' ] CHARS REVERSE JOIN   # → [ 'olleh' ]

# 文字列の長さ
[ 'hello' ] CHARS LENGTH         # → [ 'h' 'e' 'l' 'l' 'o' ] [ 5 ]

# 特定位置の文字を取得
[ 'hello' ] CHARS [ 1 ] GET      # → [ ... ] [ 'e' ]

# 部分文字列
[ 'hello' ] CHARS [ 3 ] TAKE JOIN  # → [ 'hel' ]

## エラーケース
[ '' ] CHARS                     # エラー: 空文字列
[ 42 ] CHARS                     # エラー: 数値型
[ [ 'a' ] ] CHARS                # エラー: ベクタ型

## 注意
- String型のみ受け付けます
- 空文字列はエラー（"No change is an error"原則）
- JOINワードで元の文字列に戻せます"#.to_string(),

        "JOIN" => r#"# JOIN - 文字列ベクタを連結

## 機能
文字列のベクタを連結して単一の文字列にします。
CHARSワードの逆操作として使用できます。

## 使用法（StackTopモード）
[ str1 str2 ... ] JOIN
→ 連結された文字列

## 使用法（Stackモード）
vec1 vec2 ... .. JOIN
→ 各ベクタを連結した文字列に変換

## 使用例
[ 'h' 'e' 'l' 'l' 'o' ] JOIN     # → [ 'hello' ]
[ 'hel' 'lo' ] JOIN              # → [ 'hello' ]
[ '日' '本' '語' ] JOIN          # → [ '日本語' ]
[ 'a' ] JOIN                     # → [ 'a' ]

[ 'a' 'b' ] [ 'x' 'y' ] .. JOIN  # → [ 'ab' ] [ 'xy' ]

## 活用例（CHARSとの組み合わせ）
# 文字列を反転
[ 'hello' ] CHARS REVERSE JOIN   # → [ 'olleh' ]

# 特定文字を除去（フィルタ）
# IS_NOTSPACEを定義済みとして
[ 'a b c' ] CHARS 'IS_NOTSPACE' FILTER JOIN  # → [ 'abc' ]

# 文字を変換（MAP）
# UPPER_CHARを定義済みとして
[ 'hello' ] CHARS 'UPPER_CHAR' MAP JOIN  # → [ 'HELLO' ]

## エラーケース
[ ] JOIN                         # エラー: 空ベクタ
[ 1 2 3 ] JOIN                   # エラー: 数値を含む
[ 'a' 1 'b' ] JOIN               # エラー: 混在型

## 注意
- 全要素がString型である必要があります
- 空ベクタはエラー
- 数値や他の型を含むとエラー"#.to_string(),

        // ============================================================================
        // 日付時刻操作
        // ============================================================================

        "NOW" => r#"# NOW - 現在時刻取得

## 機能
現在のUnixタイムスタンプを取得します。
1970-01-01 00:00:00 UTCからの経過秒数をミリ秒精度の分数として返します。

## 使用法
NOW
→ 現在のタイムスタンプ（分数、ミリ秒精度）

## 使用例
NOW                              # → [ 1732531200500/1000 ]
# 内部的には 1732531200.5 秒（約2024年11月25日）

NOW 'LOCAL' DATETIME             # → [ [ 2024 11 25 14 0 0 500/1000 ] ]
# 現在時刻を日付時刻Vectorに変換

## 活用例
# 処理時間の計測
NOW                              # 開始時刻
'処理' '長い処理' DEF
長い処理                          # 何らかの処理
NOW                              # 終了時刻
-                                # 経過時間（秒）

# タイムスタンプの記録
NOW '記録時刻' DEF

# 現在時刻を読みやすく表示
NOW 'LOCAL' DATETIME PRINT

## 注意
- ミリ秒精度で取得されます（分数として表現）
- タイムゾーンに依存しない絶対時刻（UTC基準）
- ブラウザのDate.now()を使用
- DATETIMEやTIMESTAMPと組み合わせる際は、タイムゾーン指定が必要"#.to_string(),

        "DATETIME" => r#"# DATETIME - 日付時刻Vectorに変換

## 機能
Unixタイムスタンプを指定したタイムゾーンでの
日付時刻Vector [年 月 日 時 分 秒] に変換します。
サブ秒精度がある場合は7番目の要素として含まれます。

**重要**: タイムゾーン指定が必須です。これにより「どのタイムゾーンか」
を常に意識することが強制され、タイムゾーン関連のバグを防ぎます。

## 使用法
[ timestamp ] 'timezone' DATETIME
→ 日付時刻Vector

## タイムゾーン指定
- 'LOCAL': ブラウザのローカルタイムゾーン（推奨）
- 将来的に他のタイムゾーン（'UTC', 'Asia/Tokyo'など）もサポート予定

## 使用例
[ 1732531200 ] 'LOCAL' DATETIME
# → [ [ 2024 11 25 14 0 0 ] ]
# ブラウザのタイムゾーンで変換

[ 1732531200 1/2 + ] 'LOCAL' DATETIME
# → [ [ 2024 11 25 14 0 0 1/2 ] ]
# サブ秒精度（0.5秒）も保持

[ 0 ] 'LOCAL' DATETIME
# → [ [ 1970 1 1 9 0 0 ] ]
# Unixエポック（Asia/Tokyoの場合は9時間のオフセット）

## 活用例
# 現在時刻を読みやすい形式で表示
NOW 'LOCAL' DATETIME PRINT

# タイムスタンプから年を取得
[ 1732531200 ] 'LOCAL' DATETIME [ 0 ] GET
# → [ [ 2024 11 25 14 0 0 ] ] [ 2024 ]

# 月だけを取得
[ 1732531200 ] 'LOCAL' DATETIME [ 1 ] GET
# → [ [ 2024 11 25 14 0 0 ] ] [ 11 ]

## Vector形式
- [年 月 日 時 分 秒]：通常の形式（サブ秒なし）
- [年 月 日 時 分 秒 サブ秒]：ミリ秒精度などを含む場合

## 設計思想
BigQuery SQLの「タイムゾーンは変換パラメータ」という思想を採用。
タイムゾーン指定を省略可能にすると、どのタイムゾーンかの意識が
薄れてしまうため、明示的な指定を必須としています。

## 注意
- タイムゾーン指定は必須（省略不可）
- 月は1-12（1月=1、12月=12）
- 日は1-31
- 時は0-23
- 分・秒は0-59
- サブ秒は分数（例：500/1000 = 0.5秒）"#.to_string(),

        // ============================================================================
        // ソートアルゴリズム
        // ============================================================================


        "FRACTIONSORT" => r#"# FRACTIONSORT - 高速分数ソート

## 機能
**分数専用の実用的高速ソートアルゴリズム**です。
整数演算のみで分数を比較し、Introsort（QuickSort + HeapSort のハイブリッド）を使用して
最高の性能を実現します。

## 速度最適化の仕組み

### 1. 整数演算による高速比較
分数の大小比較を整数演算のみで実行：

```
a/b < c/d を判定するには...

従来（浮動小数点）:
  a ÷ b を計算 → 0.666...
  c ÷ d を計算 → 0.75
  比較           → 遅い、精度損失

FRACTIONSORT（整数演算）:
  a × d < b × c を計算 → 高速、正確！
```

### 2. Introsort の採用
Rustの標準ソート（Introsort）を使用：
- QuickSort: 平均的に最速
- HeapSort: 最悪ケースを回避
- 自動切り替え: 深い再帰でHeapSortに移行

### 3. インプレース処理
余分なメモリを使用せず、効率的にソートします。

## 使用法（StackTopモード）
[ 要素... ] FRACTIONSORT
→ 昇順にソートされた新しいベクタ

## 使用法（Stackモード）
要素... .. FRACTIONSORT
→ スタック全体を昇順にソート

## 使用例
[ 1/2 1/3 2/3 1/4 3/4 ] FRACTIONSORT
# → [ 1/4 1/3 1/2 2/3 3/4 ]

[ 5/7 3/5 2/3 1/2 ] FRACTIONSORT
# → [ 1/2 3/5 2/3 5/7 ]

[ 7/3 5/2 8/3 3/1 ] FRACTIONSORT
# → [ 5/2 7/3 8/3 3/1 ]

3/4 1/2 5/8 .. FRACTIONSORT
# → 1/2 5/8 3/4

## アルゴリズムの特徴
- 時間計算量: **O(n log n)（最悪ケースでも保証）**
- 空間計算量: **O(log n)（再帰スタックのみ）**
- 安定ソート: いいえ（Introsortの特性）
- 分数専用: はい（精度100%保持）
- 浮動小数点変換なし：完全な精度を保持

## 実用例

### 大量の分数データ
```ajisai
# 1000個の分数を高速ソート
[ 0 ] [ 999 ] RANGE '1/2 +' MAP FRACTIONSORT
```

### 金融計算（為替レート）
```ajisai
# 複数通貨の為替レートをソート
[ 110/1 1350/10 8500/100 ] FRACTIONSORT
# → 正確な順序で取得
```

### 科学計算（実験データ）
```ajisai
# 測定値（分数表現）を高速ソート
[ 355/113 22/7 333/106 ] FRACTIONSORT
# πの近似値を正確にソート
```

## 技術的詳細

### 整数比較の実装
分数 a/b と c/d の比較：

```rust
// a/b < c/d ⟺ a*d < b*c
// オーバーフロー対策も含む実装
impl PartialOrd for Fraction {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        let left = &self.numerator * &other.denominator;
        let right = &other.numerator * &self.denominator;
        left.partial_cmp(&right)
    }
}
```

### Introsort の動作
1. QuickSortで分割
2. 再帰深度が 2*log₂(n) を超えたら
3. HeapSortに切り替え
4. 小さい部分配列は挿入ソート

## エラーケース
[ 1/3 1/2 2/3 ] FRACTIONSORT
# エラー: すでにソート済み（変化なし）

[ ] FRACTIONSORT
# エラー: 空のベクタはソートできません

## 注意
- 数値型（内部的には全て分数）のみソート可能
- Ajisaiでは全ての数値が分数として扱われるため、
  整数も自動的に分数（denominator=1）としてソート
- Rustの標準ソートを使用するため、
  パフォーマンスは最高レベル
- 実用的なアプリケーションで推奨"#.to_string(),

        "TIMESTAMP" => r#"# TIMESTAMP - タイムスタンプに変換

## 機能
指定したタイムゾーンでの日付時刻Vector
[年 月 日 時 分 秒] をUnixタイムスタンプに変換します。
実在しない日時（2023-13-32など）はエラーになります。

**重要**: タイムゾーン指定が必須です。これにより「どのタイムゾーンか」
を常に意識することが強制され、タイムゾーン関連のバグを防ぎます。

## 使用法
[ [ 年 月 日 時 分 秒 ] ] 'timezone' TIMESTAMP
→ タイムスタンプ（分数）

[ [ 年 月 日 時 分 秒 サブ秒 ] ] 'timezone' TIMESTAMP
→ タイムスタンプ（分数、サブ秒精度を含む）

## タイムゾーン指定
- 'LOCAL': ブラウザのローカルタイムゾーン（推奨）
- 将来的に他のタイムゾーン（'UTC', 'Asia/Tokyo'など）もサポート予定

## 使用例
[ [ 2024 11 25 14 0 0 ] ] 'LOCAL' TIMESTAMP
# → [ 1732531200 ]
# ブラウザのタイムゾーンで変換

[ [ 2024 11 25 14 0 0 1/2 ] ] 'LOCAL' TIMESTAMP
# → [ 3465062401/2 ]
# サブ秒精度（0.5秒）を含む

[ [ 1970 1 1 0 0 0 ] ] 'LOCAL' TIMESTAMP
# → [ -32400 ]
# ローカル時刻の1970-01-01 00:00:00（Asia/Tokyoの場合）

## エラーケース
[ [ 2023 13 32 0 0 0 ] ] 'LOCAL' TIMESTAMP
# エラー：実在しない日付（13月32日）

[ [ 2024 2 30 0 0 0 ] ] 'LOCAL' TIMESTAMP
# エラー：2024年2月30日は存在しない

[ [ 2024 11 25 25 0 0 ] ] 'LOCAL' TIMESTAMP
# エラー：25時は存在しない

## 活用例
# 特定の日時のタイムスタンプを取得
[ [ 2025 1 1 0 0 0 ] ] 'LOCAL' TIMESTAMP
# → 2025年1月1日0時0分0秒のタイムスタンプ

# 日付の比較（タイムスタンプ経由）
[ [ 2024 12 25 0 0 0 ] ] 'LOCAL' TIMESTAMP
[ [ 2024 12 31 0 0 0 ] ] 'LOCAL' TIMESTAMP
<
# → [ true ]（12/25 < 12/31）

# 往復変換でバリデーション
[ [ 2024 2 29 0 0 0 ] ] 'LOCAL' TIMESTAMP 'LOCAL' DATETIME
# → [ [ 2024 2 29 0 0 0 ] ]（2024年はうるう年なので有効）

## Vector形式
- [年 月 日 時 分 秒]：必須（6要素）
- [年 月 日 時 分 秒 サブ秒]：オプション（7要素）

## 設計思想
BigQuery SQLの「タイムゾーンは変換パラメータ」という思想を採用。
タイムゾーン指定を省略可能にすると、どのタイムゾーンかの意識が
薄れてしまうため、明示的な指定を必須としています。

## 注意
- タイムゾーン指定は必須（省略不可）
- 最初の6要素（年月日時分秒）は整数である必要があります
- サブ秒（7番目の要素）のみ分数可
- 実在しない日時は自動補正されずエラーになります
- JavaScriptのDateオブジェクトで検証されます"#.to_string(),

        // ============================================================================
        // 算術演算
        // ============================================================================

        "+" => r#"# + - 加算

## 機能（StackTopモード）
2つのベクタの要素ごとの加算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に加算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] +
→ 要素ごとに加算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. +
→ 指定個数の要素を加算した結果

## 使用例（StackTopモード）
[ 1 2 3 ] [ 4 5 6 ] +      # → [ 5 7 9 ]  (要素ごと)
[ 1 2 3 ] [ 10 ] +         # → [ 11 12 13 ]  (ブロードキャスト)
[ 5 ] [ 1 2 3 ] +          # → [ 6 7 8 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 1 ] [ 2 ] [ 3 ] [ 3 ] .. +   # → [ 6 ]  (1+2+3)
[ 10 ] [ 5 ] [ 2 ] .. +        # → [ 12 ]  (10+5、デフォルト2個)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[0]との加算）はエラー"#.to_string(),

        "-" => r#"# - - 減算

## 機能（StackTopモード）
2つのベクタの要素ごとの減算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に減算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] -
→ 要素ごとに減算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. -
→ 指定個数の要素を減算した結果

## 使用例（StackTopモード）
[ 5 7 9 ] [ 1 2 3 ] -      # → [ 4 5 6 ]  (要素ごと)
[ 10 20 30 ] [ 5 ] -       # → [ 5 15 25 ]  (ブロードキャスト)
[ 100 ] [ 1 2 3 ] -        # → [ 99 98 97 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 10 ] [ 3 ] [ 2 ] [ 3 ] .. -  # → [ 5 ]  (10-3-2)
[ 100 ] [ 25 ] [ 2 ] .. -      # → [ 75 ]  (100-25)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[0]との減算）はエラー"#.to_string(),

        "*" => r#"# * - 乗算

## 機能（StackTopモード）
2つのベクタの要素ごとの乗算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に乗算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] *
→ 要素ごとに乗算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. *
→ 指定個数の要素を乗算した結果

## 使用例（StackTopモード）
[ 1 2 3 ] [ 4 5 6 ] *      # → [ 4 10 18 ]  (要素ごと)
[ 1 2 3 ] [ 10 ] *         # → [ 10 20 30 ]  (ブロードキャスト)
[ 5 ] [ 2 3 4 ] *          # → [ 10 15 20 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 2 ] [ 3 ] [ 4 ] [ 3 ] .. *   # → [ 24 ]  (2*3*4)
[ 5 ] [ 6 ] [ 2 ] .. *         # → [ 30 ]  (5*6)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[1]との乗算）はエラー"#.to_string(),

        "/" => r#"# / - 除算

## 機能（StackTopモード）
2つのベクタの要素ごとの除算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。
結果は分数として正確に保持されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に除算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] /
→ 要素ごとに除算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. /
→ 指定個数の要素を除算した結果

## 使用例（StackTopモード）
[ 10 20 30 ] [ 2 4 5 ] /   # → [ 5 5 6 ]  (要素ごと)
[ 10 20 30 ] [ 10 ] /      # → [ 1 2 3 ]  (ブロードキャスト)
[ 100 ] [ 2 4 5 ] /        # → [ 50 25 20 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 100 ] [ 2 ] [ 5 ] [ 3 ] .. /  # → [ 10 ]  (100/2/5)
[ 20 ] [ 4 ] [ 2 ] .. /         # → [ 5 ]  (20/4)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 0での除算はエラー
- 演算結果が入力と同じ場合（例：[1]での除算）はエラー"#.to_string(),

        // ============================================================================
        // 比較演算
        // ============================================================================

        "=" => r#"# = - 等価比較

## 機能（StackTopモード）
2つの値を比較し、完全に等しいかどうかを判定します。
あらゆる型の値を比較可能（Number、String、Boolean、Vector、Nil）。

## 機能（Stackモード）
N個の要素を順に比較し、全て等しいかを判定します。

## 使用法
[ value1 ] [ value2 ] =
→ 等しければ [true]、異なれば [false]

## 使用例（StackTopモード）
[ 3 ] [ 3 ] =              # → [ true ]
[ 3 ] [ 5 ] =              # → [ false ]
[ 'hello' ] [ 'hello' ] =  # → [ true ]
[ 1 2 ] [ 1 2 ] =          # → [ true ]  (ベクタ全体を比較)
[ 1 2 ] [ 1 3 ] =          # → [ false ]

## 使用例（Stackモード）
[ 3 ] [ 3 ] [ 3 ] [ 3 ] .. =    # → [ true ]  (全て等しい)
[ 1 ] [ 2 ] [ 1 ] [ 3 ] .. =    # → [ false ] (1≠2)

## 注意
- ベクタ全体を1つの値として比較します
- 要素ごとの比較ではありません"#.to_string(),

        "<" => r#"# < - 小なり比較

## 機能
2つのベクタの要素ごとに「左 < 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] <
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 1 2 3 ] [ 2 2 2 ] <      # → [ true false false ]
[ 1 2 3 ] [ 3 ] <          # → [ true true false ]  (ブロードキャスト)
[ 5 ] [ 1 2 3 4 5 ] <      # → [ false false false false false ]

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        "<=" => r#"# <= - 小なりイコール比較

## 機能
2つのベクタの要素ごとに「左 <= 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] <=
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 1 2 3 ] [ 2 2 2 ] <=     # → [ true true false ]
[ 1 2 3 ] [ 3 ] <=         # → [ true true true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        ">" => r#"# > - 大なり比較

## 機能
2つのベクタの要素ごとに「左 > 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] >
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 3 2 1 ] [ 2 2 2 ] >      # → [ true false false ]
[ 5 4 3 ] [ 3 ] >          # → [ true true false ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        ">=" => r#"# >= - 大なりイコール比較

## 機能
2つのベクタの要素ごとに「左 >= 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] >=
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 3 2 1 ] [ 2 2 2 ] >=     # → [ true true false ]
[ 5 4 3 ] [ 3 ] >=         # → [ true true true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        // ============================================================================
        // 論理演算
        // ============================================================================

        "AND" => r#"# AND - 論理積

## 機能
2つのベクタの要素ごとに論理積（AND）を計算します。
要素数が等しい場合は要素ごとに演算、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] AND
→ 各要素の論理積のベクタ

## 使用例
[ true true false false ] [ true false true false ] AND
# → [ true false false false ]

[ true false true ] [ true ] AND
# → [ true false true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 要素はboolean型である必要があります"#.to_string(),

        "OR" => r#"# OR - 論理和

## 機能
2つのベクタの要素ごとに論理和（OR）を計算します。
要素数が等しい場合は要素ごとに演算、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] OR
→ 各要素の論理和のベクタ

## 使用例
[ true true false false ] [ true false true false ] OR
# → [ true true true false ]

[ true false true ] [ false ] OR
# → [ true false true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 要素はboolean型である必要があります"#.to_string(),

        "NOT" => r#"# NOT - 論理否定

## 機能
ベクタの各要素の論理否定（NOT）を計算します。

## 使用法
[ 要素... ] NOT
→ 各要素を否定したベクタ

## 使用例
[ true false true ] NOT    # → [ false true false ]
[ false ] NOT              # → [ true ]

## 注意
- 要素はboolean型である必要があります"#.to_string(),

        // ============================================================================
        // 制御構造
        // ============================================================================

        ":" => r#"# : - ガード区切り（条件分岐）

## 機能
条件による分岐を実現します。
「条件 : アクション : 条件 : アクション : デフォルト」の形式で使用します。

## 使用法
条件1 : アクション1 : 条件2 : アクション2 : ... : デフォルトアクション

## 動作
- 左から順に条件を評価
- 最初にtrueになった条件のアクションを実行
- すべての条件がfalseの場合、デフォルトアクションを実行

## 使用例
# 値が正か負かゼロかを判定
[ 5 ] [ 0 ] > : 'positive' : [ 5 ] [ 0 ] < : 'negative' : 'zero'
# → 'positive' (5 > 0がtrue)

# 単純なif-else
[ x ] [ 10 ] > : '大きい' : '小さいか等しい'

## 注意
- 条件は真偽値（true/false）を返す式である必要があります
- コロンの数は奇数個になります（条件:アクション:条件:アクション:デフォルト）"#.to_string(),

        // ============================================================================
        // 高階関数
        // ============================================================================

        "MAP" => r#"# MAP - 各要素に関数を適用

## 機能
ベクタまたはスタックの各要素に対して、指定したワードを適用します。

## 使用法（StackTopモード）
[ 要素... ] 'WORD' MAP
→ 各要素にWORDを適用した結果のベクタ

## 使用法（Stackモード）
要素... [ 個数 ] 'WORD' .. MAP
→ 指定個数の要素にWORDを適用

## 使用例
[ 1 2 3 4 ] '[ 2 ] *' MAP
# → [ 2 4 6 8 ]  (各要素を2倍)

[ 1 2 3 ] '[ 1 ] +' MAP
# → [ 2 3 4 ]  (各要素に1を加算)

# カスタムワードを使用
[ '[ 2 ] * [ 1 ] +' ] 'DOUBLE_PLUS_ONE' DEF
[ 1 2 3 ] 'DOUBLE_PLUS_ONE' MAP
# → [ 3 5 7 ]  (各要素を2倍して1を足す)

## 注意
- ワード名はシングルクォート文字列で指定
- 各要素に対して独立して実行されます"#.to_string(),

        "FILTER" => r#"# FILTER - 条件に合う要素を抽出

## 機能
ベクタの各要素に対して条件ワードを適用し、
trueを返した要素のみを残します。

## 使用法
[ 要素... ] 'WORD' FILTER
→ 条件を満たす要素のみのベクタ

## 使用例
[ 1 2 3 4 5 6 ] '[ 2 ] [ 0 ] = NOT' FILTER
# → [ 1 3 5 ]  (奇数のみ抽出)

[ 10 5 20 3 15 ] '[ 10 ] >' FILTER
# → [ 20 15 ]  (10より大きい要素)

# カスタムワードを使用
[ '[ 5 ] >' ] 'IS_LARGE' DEF
[ 1 3 8 2 7 ] 'IS_LARGE' FILTER
# → [ 8 7 ]  (5より大きい要素)

## 注意
- ワード名はシングルクォート文字列で指定
- 条件ワードはtrue/falseを返す必要があります"#.to_string(),

        "COUNT" => r#"# COUNT - 条件に合う要素を数える

## 機能
ベクタまたはスタックの各要素に対して条件ワードを適用し、
trueを返した要素の数を数えます。
FILTER + LENGTH の簡略版として使用できます。

## 使用法（StackTopモード）
[ 要素... ] 'WORD' COUNT
→ 元のベクタを保持し、条件を満たす要素数を追加

## 使用法（Stackモード）
要素... [ 個数 ] 'WORD' .. COUNT
→ 元のスタックを保持し、条件を満たす要素数を追加

## 使用例
[ 1 2 3 4 5 ] '[ 2 ] >' COUNT
# → [ 1 2 3 4 5 ] [ 3 ]  (2より大きい要素が3個)

[ 1 2 3 4 5 6 ] '[ 2 ] [ 0 ] = NOT' COUNT
# → [ 1 2 3 4 5 6 ] [ 3 ]  (奇数が3個)

[ 10 5 20 3 15 ] '[ 10 ] >=' COUNT
# → [ 10 5 20 3 15 ] [ 3 ]  (10以上の要素が3個)

# カスタムワードを使用
[ '[ 5 ] >' ] 'IS_LARGE' DEF
[ 1 3 8 2 7 ] 'IS_LARGE' COUNT
# → [ 1 3 8 2 7 ] [ 2 ]  (5より大きい要素が2個)

## Stackモード例
1 2 3 4 5 [ 5 ] '[ 3 ] >' .. COUNT
# → 1 2 3 4 5 [ 2 ]  (3より大きい要素が2個)

## 比較: FILTERとCOUNT
# FILTER: 条件を満たす要素を抽出
[ 1 2 3 4 5 ] '[ 2 ] >' FILTER
# → [ 3 4 5 ]

# COUNT: 条件を満たす要素の個数
[ 1 2 3 4 5 ] '[ 2 ] >' COUNT
# → [ 1 2 3 4 5 ] [ 3 ]

## 注意
- ワード名はシングルクォート文字列で指定
- 条件ワードはtrue/falseを返す必要があります
- 元のベクタ/スタックは変更されません"#.to_string(),

        "REDUCE" => r#"# REDUCE - 二項演算による畳み込み

## 機能
ベクタまたはスタック上の要素を、指定した二項演算ワードで左から右へ畳み込み、
単一の結果に集約します。

## 畳み込みの順序
左から右へ順番に演算を適用します：
[ a b c d ] 'OP' REDUCE = ((a OP b) OP c) OP d

## 使用法（StackTopモード）
[ 要素... ] 'ワード名' REDUCE
→ 畳み込んだ結果を単一要素ベクタとして返す

## 使用法（Stackモード）
要素... [ 個数 ] 'ワード名' .. REDUCE
→ スタック上のN個の要素を畳み込む

## 使用例
[ 1 2 3 4 5 ] '+' REDUCE       # → [ 15 ]  (1+2+3+4+5)
[ 1 2 3 4 5 ] '*' REDUCE       # → [ 120 ] (1*2*3*4*5 = 5!)
[ 10 3 1 ] '-' REDUCE          # → [ 6 ]   (10-3-1)
[ 100 2 5 ] '/' REDUCE         # → [ 10 ]  (100/2/5)

# 最大値を求める（カスタムワード使用）
[ ': [0] [1] >
: [0]
: [1]' ] 'MAX2' DEF
[ 3 1 4 1 5 9 2 6 ] 'MAX2' REDUCE   # → [ 9 ]

# Stackモード
[1] [2] [3] [4] [5] [5] '+' .. REDUCE   # → [ 15 ]

## 畳み込みの動作（詳細）
[ 1 2 3 4 ] '+' REDUCE の処理順序：
1. acc = 1 (初期値は最初の要素)
2. acc = acc + 2 = 3
3. acc = acc + 3 = 6
4. acc = acc + 4 = 10
5. 結果: [ 10 ]

## 注意
- 空のベクタに対してはエラー
- 単一要素のベクタに対してはエラー（変化がないため）
- 適用するワードは2つの単一要素ベクタを受け取り、1つを返す必要がある
- 減算・除算は左から右への適用順序に注意
- 組み込みワード（+, -, *, /）とカスタムワードの両方が使用可能"#.to_string(),

        "FOLD" => r#"# FOLD - 初期値付き畳み込み

## 機能
ベクタまたはスタック上の要素を、初期値から始めて二項演算ワードで畳み込み、
単一の結果に集約します。REDUCEと異なり、初期値を明示的に指定できます。

## REDUCEとの違い
- REDUCE: 最初の要素を初期値として使用、空ベクタでエラー
- FOLD: 初期値を明示的に指定、空ベクタでは初期値をそのまま返す

## 畳み込みの順序
左から右へ順番に演算を適用します：
[ a b c ] [init] 'OP' FOLD = ((init OP a) OP b) OP c

## 使用法（StackTopモード）
[ 要素... ] [ 初期値 ] 'ワード名' FOLD
→ 畳み込んだ結果を単一要素ベクタとして返す

## 使用法（Stackモード）
要素... [ 個数 ] [ 初期値 ] 'ワード名' .. FOLD
→ スタック上のN個の要素を初期値から畳み込む

## 使用例
[ 1 2 3 4 ] [ 0 ] '+' FOLD     # → [ 10 ]  (0+1+2+3+4)
[ 1 2 3 4 ] [ 1 ] '*' FOLD     # → [ 24 ]  (1*1*2*3*4)
[ 1 2 3 ] [ 10 ] '-' FOLD      # → [ 4 ]   (10-1-2-3)

# 空ベクタの場合は初期値がそのまま返る
[ ] [ 42 ] '+' FOLD            # → [ 42 ]

# 文字列連結（カスタムワード使用）
[ '[ 2 ] CONCAT' ] 'STRCAT' DEF
[ 'a' 'b' 'c' ] [ '' ] 'STRCAT' FOLD   # → [ 'abc' ]

# Stackモード
[1] [2] [3] [3] [0] '+' .. FOLD   # → [ 6 ]  (0+1+2+3)

## 畳み込みの動作（詳細）
[ 1 2 3 ] [ 0 ] '+' FOLD の処理順序：
1. acc = 0 (初期値)
2. acc = acc + 1 = 1
3. acc = acc + 2 = 3
4. acc = acc + 3 = 6
5. 結果: [ 6 ]

## 注意
- 空のベクタに対しては初期値をそのまま返す（エラーにならない）
- 単一要素のベクタに対しても正常動作（init OP x を計算）
- 適用するワードは2つの単一要素ベクタを受け取り、1つを返す必要がある
- 組み込みワード（+, -, *, /）とカスタムワードの両方が使用可能"#.to_string(),

        "UNFOLD" => r#"# UNFOLD - 状態からベクタを生成

## 機能
初期状態から始めて、ワードを繰り返し適用してベクタを生成します。
Haskellの unfoldr に相当する高階関数です。

## 使用法（StackTopモード）
[ 初期状態 ] 'ワード名' UNFOLD
→ 生成された要素のベクタを返す

## 使用法（Stackモード）
[ 初期状態 ] 'ワード名' .. UNFOLD
→ 生成された要素をスタックに直接展開

## ワードの仕様
ワードは以下のいずれかを返す必要があります：
- [ 要素 次の状態 ] : 要素を生成し、次の状態で続行
- [ 要素 NIL ] : 要素を生成し、終了
- NIL : 即座に終了（要素を生成しない）

## 使用例

# 1から5までの数列を生成
[ ': [0] [0] GET [5] >
: NIL
: [0] [0] GET [0] [0] GET [1] +' ] 'RANGE5' DEF
[ 1 ] 'RANGE5' UNFOLD    # → [ 1 2 3 4 5 ]

# 常に同じ値を10個生成
[ ': [0] [1] GET [10] >=
: NIL
: [42] [0] [1] GET [1] +' ] 'TEN_42S' DEF
[ 42 0 ] 'TEN_42S' UNFOLD    # → [ 42 42 42 42 42 42 42 42 42 42 ]

# 空ベクタの生成（即座にNILを返す）
[ ': NIL' ] 'STOPNOW' DEF
[ 1 ] 'STOPNOW' UNFOLD    # → [ ]

## UNFOLDの動作（詳細）
[ 1 ] 'RANGE5' UNFOLD の処理順序：
1. state = [ 1 ]
2. 'RANGE5'を実行 → [ 1 2 ] (要素1, 次の状態2)
3. state = [ 2 ]
4. 'RANGE5'を実行 → [ 2 3 ]
5. state = [ 3 ]
6. 'RANGE5'を実行 → [ 3 4 ]
7. state = [ 4 ]
8. 'RANGE5'を実行 → [ 4 5 ]
9. state = [ 5 ]
10. 'RANGE5'を実行 → NIL (5 > 5 なので終了)
11. 結果: [ 1 2 3 4 5 ]

## 注意
- 最大10000回のイテレーションでエラー（無限ループ防止）
- 空のベクタを生成することも可能（即座にNILを返す場合）
- ワードが不正な値を返した場合はエラー
- FOLDの逆操作に相当（FOLDは畳み込み、UNFOLDは展開）"#.to_string(),

        // ============================================================================
        // 入出力
        // ============================================================================

        "PRINT" => r#"# PRINT - 要素を出力

## 機能
スタックトップの要素を出力バッファに書き込みます。
要素はスタックから除去されます。

## 使用法
要素 PRINT
→ 要素を出力し、スタックから削除

## 使用例
[ 42 ] PRINT              # 出力: 42
'Hello' PRINT             # 出力: Hello
[ 1 2 3 ] PRINT           # 出力: [1 2 3]

# 複数の値を出力
[ 1 ] [ 2 ] [ 3 ]
PRINT PRINT PRINT         # 出力: 1 2 3

## 注意
- 出力後、要素はスタックから削除されます
- 出力フォーマットは要素の型によって自動的に決定されます"#.to_string(),

        // ============================================================================
        // ワード管理
        // ============================================================================

        "DEF" => r#"# DEF - カスタムワードを定義

## 機能
新しいカスタムワードを定義し、辞書に登録します。

## 使用法
[ '定義内容' ] 'NAME' DEF               # 説明なし
[ '定義内容' ] 'NAME' '説明' DEF       # 説明あり

## 使用例
# 単純なワード定義
[ '[ 2 ] *' ] 'DOUBLE' DEF
[ 5 ] DOUBLE                # → [ 10 ]

# 複数行の定義（改行を含む）
[ '[ 1 ] +
  [ 2 ] *' ] 'INC_AND_DOUBLE' DEF
[ 5 ] INC_AND_DOUBLE        # → [ 12 ]  ((5+1)*2)

# 説明付きの定義
[ '[ 3 ] *' ] 'TRIPLE' '値を3倍にする' DEF
'TRIPLE' ?                  # 説明が表示される

## 注意
- ワード名は自動的に大文字に変換されます
- 組み込みワードは上書きできません
- 既存のカスタムワードは上書きされます
- 定義内容はシングルクォート文字列で指定します"#.to_string(),

        "DEL" => r#"# DEL - カスタムワードを削除

## 機能
辞書からカスタムワードを削除します。

## 使用法
'NAME' DEL
→ 指定したワードを辞書から削除

## 使用例
# ワードを定義して削除
[ '[ 2 ] *' ] 'DOUBLE' DEF
'DOUBLE' DEL                # DOUBLEが削除される

# 削除後は使用不可
[ 5 ] DOUBLE                # エラー: Unknown word

## 注意
- 組み込みワードは削除できません
- 存在しないワードを削除しようとするとエラー
- ワード名は自動的に大文字に変換されます"#.to_string(),

        "?" => r#"# ? - ワード定義を参照

## 機能
ワードの定義や説明をInputエリアに呼び出します。

## 使用法
'NAME' ?
→ ワードの定義をInputエリアに読み込み

## 動作
【組み込みワードの場合】
- 詳細な説明、使用法、使用例が表示されます
- 機能、構文、注意事項などの情報が含まれます

【カスタムワードの場合】
- 定義時の記述がそのまま表示されます
- 改行、#コメントなども含めて完全に再現されます
- DEF文として呼び出されるため、再定義が簡単です

## 使用例
'GET' ?                     # GETの詳細な説明が表示される
'DOUBLE' ?                  # DOUBLEの定義が表示される

# カスタムワードの定義を確認して修正
[ '[ 2 ] *' ] 'DOUBLE' DEF
'DOUBLE' ?                  # [ '[ 2 ] *' ] 'DOUBLE' DEF
# ↑ Inputエリアに読み込まれるので、編集して再定義可能

## 注意
- ワード名は自動的に大文字に変換されます
- 存在しないワードを参照するとエラー"#.to_string(),

        // ============================================================================
        // 入力支援
        // ============================================================================

        "'" => r#"# ' - シングルクォート挿入

## 機能
Inputエリアにシングルクォート(')を挿入します。
入力支援のための便利機能です。

## 使用法
ボタンをクリックすると、カーソル位置にシングルクォートが挿入されます。

## 使用例
キーボード入力: [  ]  →  ボタン「'」クリック  →  [ '' ]
（カーソルがクォートの間に配置されます）

## 注意
- これは実行可能なワードではなく、入力支援機能です"#.to_string(),

        "[ ]" => r#"# [ ] - 空ベクタ挿入

## 機能
Inputエリアに空ベクタの括弧 [ ] を挿入します。
入力支援のための便利機能です。

## 使用法
ボタンをクリックすると、カーソル位置に [ ] が挿入されます。

## 使用例
ボタン「[ ]」クリック  →  [ ]
（カーソルが括弧の間に配置されます）

## 注意
- これは実行可能なワードではなく、入力支援機能です"#.to_string(),

        "!" => r#"# ! - 強制実行演算子

## 機能
依存関係のあるカスタムワードの削除（DEL）や再定義（DEF）を許可します。
他のカスタムワードから参照されているワードを操作する際に使用します。

## 使用法
! 'WORDNAME' DEL     # 強制削除
! [ ': ...' ] 'WORDNAME' DEF  # 強制再定義

## 使用例
[ ': [ 2 ] *' ] 'DOUBLE' DEF
[ ': DOUBLE DOUBLE' ] 'QUAD' DEF

'DOUBLE' DEL           # Error: referenced by QUAD
! 'DOUBLE' DEL         # OK（警告付きで削除）

[ ': [ 3 ] *' ] 'DOUBLE' DEF     # Error: referenced by QUAD
! [ ': [ 3 ] *' ] 'DOUBLE' DEF   # OK（警告付きで再定義）

## 注意
- 組み込みワードには効果がありません（常にエラー）
- フラグは次のDEL/DEF実行後に自動リセットされます
- 依存関係のないワードには ! は不要です
- !はDEL/DEFの前に置く必要があります（後置記法のため）"#.to_string(),

        _ => {
            // 既存の定義情報にフォールバック
            let definitions = get_builtin_definitions();
            for (word_name, description, category) in definitions {
                if word_name == name {
                    return format!("# {} - {}\n\nCategory: {}\n\n## 説明\n{}\n\n詳細な説明は未実装です。",
                        name, description, category, description);
                }
            }
            format!("ワード '{}' の詳細情報はありません。", name)
        }
    }.to_string()
}
