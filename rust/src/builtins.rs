// rust/src/builtins.rs

use std::collections::{HashMap, HashSet};
use crate::types::WordDefinition;

pub fn register_builtins(dictionary: &mut HashMap<String, WordDefinition>) {
    for (name, description, _) in get_builtin_definitions() {
        dictionary.insert(name.to_string(), WordDefinition {
            lines: vec![],
            is_builtin: true,
            description: Some(description.to_string()),
            dependencies: HashSet::new(),
            original_source: None,
        });
    }
}

pub fn get_builtin_definitions() -> Vec<(&'static str, &'static str, &'static str)> {
    vec![
        // 操作対象指定
        (".", "操作対象をスタックトップに設定（デフォルト）｜. + → スタックトップに加算", "Target"),
        ("..", "操作対象をスタック全体に設定｜.. + [ 3 ] → スタック全要素に3を加算", "Target"),

        // 入力支援
        ("'", "シングルクォートを入力｜' → '", "Input Helper"),
        ("SCALAR", "1次元ブラケットを入力｜SCALAR → [ ]、[ 2 ] SCALAR → [ [ ] [ ] ]", "Input Helper"),
        ("VECTOR", "2次元ブラケットを入力｜VECTOR → [ [ ] ]、[ 2 ] VECTOR → [ [ [ ] ] [ [ ] ] ]", "Input Helper"),
        ("MATRIX", "3次元ブラケットを入力｜MATRIX → [ [ [ ] ] ]", "Input Helper"),
        ("TENSOR", "4次元ブラケットを入力｜TENSOR → [ [ [ [ ] ] ] ]", "Input Helper"),

        // 位置指定操作(0オリジン)
        ("GET", "指定位置の要素を取得（0オリジン）｜[ 10 20 30 ] [ 0 ] GET → [ 10 20 30 ] [ 10 ]", "Position"),
        ("INSERT", "指定位置に要素を挿入｜[ 1 3 ] [ 1 ] [ 2 ] INSERT → [ 1 2 3 ]", "Position"),
        ("REPLACE", "指定位置の要素を置換｜[ 1 2 3 ] [ 0 ] [ 9 ] REPLACE → [ 9 2 3 ]", "Position"),
        ("REMOVE", "指定位置の要素を削除｜[ 1 2 3 ] [ 0 ] REMOVE → [ 2 3 ]", "Position"),

        // 量指定操作(1オリジン)
        ("LENGTH", "ベクタの長さを取得｜[ 1 2 3 4 5 ] LENGTH → [ 1 2 3 4 5 ] [ 5 ]", "Quantity"),
        ("TAKE", "先頭または末尾からN個の要素を取得｜[ 1 2 3 4 5 ] [ 3 ] TAKE → [ 1 2 3 ]", "Quantity"),

        // Vector構造操作
        ("SPLIT", "ベクタを指定サイズで分割｜[ 1 2 3 4 5 6 ] [ 2 ] [ 3 ] SPLIT → [ 1 2 ] [ 3 4 5 ] [ 6 ]", "Vector"),
        ("CONCAT", "ベクタを連結｜[ 1 2 ] [ 3 4 ] CONCAT → [ 1 2 3 4 ]", "Vector"),
        ("REVERSE", "ベクタの要素を反転｜[ 1 2 3 ] REVERSE → [ 3 2 1 ]", "Vector"),
        ("RANGE", "数値範囲を生成｜[ 0 ] [ 5 ] RANGE → [ 0 ] [ 5 ] [ 0 1 2 3 4 5 ]", "Vector"),
        ("SORT", "ベクタの要素を昇順に並べ替える｜[ 3 1 2 ] SORT → [ 1 2 3 ]", "Sorting"),

        // テンソル形状操作
        ("SHAPE", "テンソルの形状を取得｜[ [ 1 2 ] [ 3 4 ] ] SHAPE → [ [ 1 2 ] [ 3 4 ] ] [ 2 2 ]", "Tensor"),
        ("RANK", "テンソルの次元数を取得｜[ [ 1 2 ] [ 3 4 ] ] RANK → [ [ 1 2 ] [ 3 4 ] ] [ 2 ]", "Tensor"),
        ("RESHAPE", "テンソルの形状を変更｜[ 1 2 3 4 ] [ 2 2 ] RESHAPE → [ [ 1 2 ] [ 3 4 ] ]", "Tensor"),
        ("TRANSPOSE", "2次元テンソルの転置｜[ [ 1 2 ] [ 3 4 ] ] TRANSPOSE → [ [ 1 3 ] [ 2 4 ] ]", "Tensor"),

        // 型変換
        ("STR", "任意の型を文字列に変換｜[ 42 ] STR → [ '42' ], [ TRUE ] STR → [ 'TRUE' ]", "Type Conversion"),
        ("NUM", "文字列または真偽値を数値に変換｜[ '42' ] NUM → [ 42 ], [ TRUE ] NUM → [ 1 ]", "Type Conversion"),
        ("BOOL", "文字列または数値を真偽値に変換｜[ 'TRUE' ] BOOL → [ TRUE ], [ '1' ] BOOL → [ TRUE ], [ 1 ] BOOL → [ TRUE ]", "Type Conversion"),
        ("NIL", "文字列をNilに変換｜[ 'nil' ] NIL → [ nil ]", "Type Conversion"),
        ("CHARS", "文字列を文字ベクタに分解｜[ 'hello' ] CHARS → [ 'h' 'e' 'l' 'l' 'o' ]", "Type Conversion"),
        ("JOIN", "文字列ベクタを連結｜[ 'h' 'e' 'l' 'l' 'o' ] JOIN → [ 'hello' ]", "Type Conversion"),
        ("NOW", "現在時刻を取得（DateTime型）｜NOW → [ @2024-11-25 14:00:00.500 ]（内部は分数）", "DateTime"),
        ("DATETIME", "タイムスタンプを日付時刻Vectorに変換｜[ 1732531200 ] 'LOCAL' DATETIME → [ [ 2024 11 25 14 0 0 ] ]", "DateTime"),
        ("TIMESTAMP", "日付時刻VectorをDateTime型に変換｜[ [ 2024 11 25 14 0 0 ] ] 'LOCAL' TIMESTAMP → [ @2024-11-25 14:00:00 ]", "DateTime"),

        // 算術演算
        ("+", "要素ごとの加算または集約｜[ 1 2 ] [ 3 4 ] + → [ 4 6 ]", "Arithmetic"),
        ("-", "要素ごとの減算または集約｜[ 5 3 ] [ 2 1 ] - → [ 3 2 ]", "Arithmetic"),
        ("*", "要素ごとの乗算または集約｜[ 2 3 ] [ 4 5 ] * → [ 8 15 ]", "Arithmetic"),
        ("/", "要素ごとの除算または集約｜[ 10 20 ] [ 2 4 ] / → [ 5 5 ]", "Arithmetic"),

        // 比較演算
        ("=", "ベクタが等しいか判定｜[ 1 2 ] [ 1 2 ] = → [ TRUE ]", "Comparison"),
        ("<", "ベクタが小さいか判定｜[ 1 ] [ 2 ] < → [ TRUE ]", "Comparison"),
        ("<=", "ベクタが小さいまたは等しいか判定｜[ 1 ] [ 1 ] <= → [ TRUE ]", "Comparison"),
        (">", "ベクタが大きいか判定｜[ 3 ] [ 2 ] > → [ TRUE ]", "Comparison"),
        (">=", "ベクタが大きいまたは等しいか判定｜[ 2 ] [ 2 ] >= → [ TRUE ]", "Comparison"),

        // 論理演算
        ("AND", "ベクタの論理積｜[ TRUE FALSE ] [ TRUE TRUE ] AND → [ TRUE FALSE ]", "Logic"),
        ("OR", "ベクタの論理和｜[ TRUE FALSE ] [ FALSE FALSE ] OR → [ TRUE FALSE ]", "Logic"),
        ("NOT", "ベクタの論理否定｜[ TRUE FALSE ] NOT → [ FALSE TRUE ]", "Logic"),

        // 制御構造(ガード)
        (":", "条件分岐のガード区切り｜条件 : 処理 : 条件 : 処理 : デフォルト処理", "Control"),

        // 高階関数
        ("MAP", "各要素にワードを適用｜[ 1 2 3 ] '2倍' MAP → [ 2 4 6 ]", "Higher-Order"),
        ("FILTER", "条件に合う要素を抽出｜[ 1 2 3 4 ] '偶数?' FILTER → [ 2 4 ]", "Higher-Order"),
        ("FOLD", "初期値付き畳み込み｜[ 1 2 3 4 ] [ 0 ] '+' FOLD → [ 10 ]", "Higher-Order"),
        ("UNFOLD", "状態からベクタ生成｜[ 1 ] 'GEN' UNFOLD → [ ... ]", "Higher-Order"),

        // 入出力
        ("PRINT", "スタックトップを出力して削除｜[ 42 ] PRINT → （42を出力）", "I/O"),
        ("AUDIO", "ベクタ要素を音声として再生｜[ 1209/697 ] AUDIO → DTMF信号再生（分子と分母を周波数として同時再生）", "I/O"),

        // カスタムワード管理
        ("DEF", "カスタムワードを定義｜[ '[ 2 ] *' ] 'DOUBLE' DEF", "Word Management"),
        ("DEL", "カスタムワードを削除｜'不要なワード' DEL", "Word Management"),
        ("?", "ワード定義を表示｜'2倍' ?", "Word Management"),

        // 制御フロー（TIMES/WAIT）
        ("TIMES", "ワードをN回繰り返し実行｜'処理' [ 5 ] TIMES", "Control Flow"),
        ("WAIT", "指定ミリ秒後にワードを実行｜'処理' [ 1000 ] WAIT", "Control Flow"),
        ("!", "強制実行フラグ｜依存のあるワードのDEL/DEFを許可｜! 'WORD' DEL", "Control Flow"),

        // 基本数学関数
        ("MOD", "剰余（数学的）｜[ 7 ] [ 3 ] MOD → [ 1 ]", "Math"),
        ("FLOOR", "切り捨て（負の無限大方向）｜[ 7/3 ] FLOOR → [ 2 ]", "Math"),
        ("CEIL", "切り上げ（正の無限大方向）｜[ 7/3 ] CEIL → [ 3 ]", "Math"),
        ("ROUND", "四捨五入（0から遠い方向）｜[ 5/2 ] ROUND → [ 3 ]", "Math"),

        // テンソル生成
        ("FILL", "任意値埋めテンソル生成｜[ 2 3 ] [ 5 ] FILL → [ [ 5 5 5 ] [ 5 5 5 ] ]", "Tensor Generation"),

        // 暗号論的乱数生成
        ("CSPRNG", "暗号論的疑似乱数を生成｜[ 6 ] [ 1 ] CSPRNG → [ 0 ]〜[ 5/6 ]（自動約分）、[ 5 ] CSPRNG → 5個生成", "Random"),

        // ハッシュ関数
        ("HASH", "任意の値を決定論的にハッシュ化｜'hello' HASH → [ 0.xxx ]、[ 128 ] 'hello' HASH → 128ビット出力", "Hash"),
    ]
}

pub fn get_builtin_detail(name: &str) -> String {
    match name {
        // ============================================================================
        // 操作対象指定
        // ============================================================================

        "." => r#"# . - スタックトップ指定

## 機能
操作対象をスタックトップ（最上位のベクタ）に設定します。
デフォルトの動作モードなので、通常は明示的な指定は不要です。

## 使用法
. WORD
→ 次のワードをスタックトップに対して実行

## 使用例
[ 1 2 3 ] . LENGTH     # → [ 1 2 3 ] [ 3 ]
[ 1 2 3 ] LENGTH       # 同じ結果（デフォルト）

## 注意
- これはデフォルトモードなので、通常は省略可能です
- ワード実行後、自動的にこのモードにリセットされます"#.to_string(),

        ".." => r#"# .. - スタック全体指定

## 機能
操作対象をスタック全体に設定します。
多くの組み込みワードがスタックモードに対応しています。

## 使用法
.. WORD
→ 次のワードをスタック全体に対して実行

## 使用例
a b c [ 1 ] .. GET      # → a b c [ b ]
（スタック全体から1番目を取得）

1 2 3 4 5 .. LENGTH     # → 1 2 3 4 5 [ 5 ]
（スタックの要素数を取得）

a b c .. REVERSE        # → c b a
（スタック全体を反転）

## 対応ワード
GET, INSERT, REPLACE, REMOVE, LENGTH, TAKE, SPLIT,
CONCAT, REVERSE, LEVEL, +, -, *, /, MAP など

## 注意
- ワード実行後、自動的にスタックトップモード(.)にリセットされます"#.to_string(),

        // ============================================================================
        // 位置指定操作（0オリジン）
        // ============================================================================

        "GET" => r#"# GET - 指定位置の要素を取得

## 機能
ベクタまたはスタックから、指定した位置（0オリジン）の要素を取得します。
負のインデックスを使用すると、末尾から数えて要素を取得できます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] GET
→ 元のベクタを保持し、取得した要素を新しいベクタとしてプッシュ

## 使用法（Stackモード）
要素... [ インデックス ] .. GET
→ スタック全体から指定位置の要素を取得

## 使用例
[ 10 20 30 ] [ 0 ] GET    # → [ 10 20 30 ] [ 10 ]  (0番目=最初の要素)
[ 10 20 30 ] [ 1 ] GET    # → [ 10 20 30 ] [ 20 ]  (1番目=2番目の要素)
[ 10 20 30 ] [ -1 ] GET   # → [ 10 20 30 ] [ 30 ]  (-1=末尾の要素)
[ 10 20 30 ] [ -2 ] GET   # → [ 10 20 30 ] [ 20 ]  (-2=末尾から2番目)

a b c [ 1 ] .. GET     # → a b c [ b ]  (スタックの1番目を取得)

## 注意
- インデックスが範囲外の場合はエラー
- 空のベクタ/スタックに対する操作はエラー"#.to_string(),

        "INSERT" => r#"# INSERT - 指定位置に要素を挿入

## 機能
ベクタまたはスタックの指定位置（0オリジン）に要素を挿入します。
負のインデックスを使用すると、末尾から数えた位置に挿入できます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] [ 挿入する要素 ] INSERT
→ 指定位置に要素を挿入した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス ] 挿入する要素 .. INSERT
→ スタックの指定位置に要素を挿入

## 使用例
[ 1 3 ] [ 1 ] [ 2 ] INSERT        # → [ 1 2 3 ]  (1番目の位置に2を挿入)
[ a c ] [ 0 ] [ b ] INSERT        # → [ b a c ]  (0番目=先頭に挿入)
[ 1 2 3 ] [ -1 ] [ 9 ] INSERT     # → [ 1 2 9 3 ]  (末尾の要素の前に挿入)
[ 1 2 3 ] [ 3 ] [ 4 ] INSERT      # → [ 1 2 3 4 ]  (末尾への追加も可能)

a c [ 1 ] b .. INSERT          # → a b c  (スタックの1番目にbを挿入)

## 注意
- 単一要素ベクタは自動的にアンラップされます
- 負のインデックスは要素の位置を指します（-1=末尾の要素の位置）"#.to_string(),

        "REPLACE" => r#"# REPLACE - 指定位置の要素を置換

## 機能
ベクタまたはスタックの指定位置（0オリジン）の要素を新しい要素で置き換えます。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] [ 新しい要素 ] REPLACE
→ 指定位置の要素を置換した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス ] 新しい要素 .. REPLACE
→ スタックの指定位置の要素を置換

## 使用例
[ 1 2 3 ] [ 0 ] [ 9 ] REPLACE    # → [ 9 2 3 ]  (0番目=最初の要素を9に)
[ 1 2 3 ] [ 1 ] [ 5 ] REPLACE    # → [ 1 5 3 ]  (1番目=2番目の要素を5に)
[ 1 2 3 ] [ -1 ] [ 9 ] REPLACE   # → [ 1 2 9 ]  (-1=末尾を9に)

a b c [ 1 ] X .. REPLACE      # → a X c  (スタックの1番目をXに)

## 注意
- インデックスが範囲外の場合はエラー
- 単一要素ベクタは自動的にアンラップされます"#.to_string(),

        "REMOVE" => r#"# REMOVE - 指定位置の要素を削除

## 機能
ベクタまたはスタックの指定位置（0オリジン）の要素を削除します。

## 使用法（StackTopモード）
[ 要素... ] [ インデックス ] REMOVE
→ 指定位置の要素を削除した新しいベクタを返す

## 使用法（Stackモード）
要素... [ インデックス ] .. REMOVE
→ スタックの指定位置の要素を削除

## 使用例
[ 1 2 3 ] [ 0 ] REMOVE      # → [ 2 3 ]  (0番目=最初の要素を削除)
[ 1 2 3 ] [ 1 ] REMOVE      # → [ 1 3 ]  (1番目=2番目の要素を削除)
[ 1 2 3 ] [ -1 ] REMOVE     # → [ 1 2 ]  (-1=末尾を削除)
[ 1 2 3 4 ] [ -2 ] REMOVE   # → [ 1 2 4 ]  (-2=末尾から2番目を削除)

a b c [ 1 ] .. REMOVE    # → a c  (スタックの1番目を削除)

## 注意
- インデックスが範囲外の場合はエラー"#.to_string(),

        // ============================================================================
        // 量指定操作（1オリジン）
        // ============================================================================

        "LENGTH" => r#"# LENGTH - 要素数を取得

## 機能
ベクタまたはスタック全体の要素数を取得します。

## 使用法（StackTopモード）
[ 要素... ] LENGTH
→ 元のベクタを保持し、要素数を新しいベクタとしてプッシュ

## 使用法（Stackモード）
要素... .. LENGTH
→ スタック全体の要素数をプッシュ

## 使用例
[ 1 2 3 4 5 ] LENGTH    # → [ 1 2 3 4 5 ] [ 5 ]  (5個の要素)
[ ] LENGTH              # → [ ] [ 0 ]  (空ベクタは0)
[ 42 ] LENGTH           # → [ 42 ] [ 1 ]  (1個の要素)

a b c d .. LENGTH    # → a b c d [ 4 ]  (スタックに4個)

## 注意
- StackTopモードでは対象がベクタでない場合はエラー"#.to_string(),

        "TAKE" => r#"# TAKE - 先頭または末尾から指定数の要素を取得

## 機能
正の数を指定すると先頭から、負の数を指定すると末尾から、
指定した個数の要素を取得します。

## 使用法（StackTopモード）
[ 要素... ] [ 個数 ] TAKE
→ 取得した要素からなる新しいベクタを返す

## 使用法（Stackモード）
要素... [ 個数 ] .. TAKE
→ スタックを指定個数の要素に切り詰める

## 使用例
[ 1 2 3 4 5 ] [ 3 ] TAKE     # → [ 1 2 3 ]  (先頭から3個)
[ 1 2 3 4 5 ] [ -2 ] TAKE    # → [ 4 5 ]  (末尾から2個)
[ 1 2 3 4 5 ] [ 1 ] TAKE     # → [ 1 ]  (先頭1個)

a b c d e [ 3 ] .. TAKE   # → a b c  (先頭3個だけ残す)
a b c d e [ -2 ] .. TAKE  # → d e  (末尾2個だけ残す)

## 注意
- 指定個数が要素数を超える場合はエラー
- 0を指定した場合の動作は未定義"#.to_string(),

        "SPLIT" => r#"# SPLIT - 指定サイズで分割

## 機能
ベクタまたはスタックを、指定したサイズに分割します。
複数のサイズを指定でき、余りは最後のベクタに含まれます。

## 使用法（StackTopモード）
[ 要素... ] [ サイズ1 ] [ サイズ2 ] ... SPLIT
→ 分割された複数のベクタをプッシュ

## 使用法（Stackモード）
要素... [ サイズ1 ] [ サイズ2 ] ... .. SPLIT
→ スタックを分割し、結果をベクタとしてプッシュ

## 使用例
[ 1 2 3 4 5 6 ] [ 2 ] [ 3 ] [ 1 ] SPLIT
# → [ 1 2 ] [ 3 4 5 ] [ 6 ]  (2個、3個、1個に分割)

[ 1 2 3 4 5 6 ] [ 2 ] [ 2 ] SPLIT
# → [ 1 2 ] [ 3 4 ] [ 5 6 ]  (余りも自動的にベクタに)

a b c d e [ 2 ] [ 1 ] .. SPLIT
# → [ a b ] [ c ] [ d e ]  (スタックを分割)

## 注意
- サイズの合計が要素数を超える場合はエラー
- 最低1つのサイズ指定が必要"#.to_string(),

        // ============================================================================
        // ベクタ構造操作
        // ============================================================================

        "CONCAT" => r#"# CONCAT - ベクタを連結

## 機能
複数のベクタを1つに連結します。
デフォルトは2個、個数を指定可能。負数で逆順連結。

## 使用法（StackTopモード）
vec1 vec2 CONCAT              # 2個を連結（デフォルト）
vec1 vec2 vec3 [ 3 ] CONCAT   # 3個を連結
vec1 vec2 vec3 [ -3 ] CONCAT  # 3個を逆順で連結

## 使用法（Stackモード）
要素... .. CONCAT          # スタック全体を連結
要素... [ 個数 ] .. CONCAT # 指定個数を連結

## 使用例
[ a ] [ b ] CONCAT                # → [ a b ]  (デフォルト2個)
[ a ] [ b ] [ c ] [ 3 ] CONCAT    # → [ a b c ]  (3個を連結)
[ a ] [ b ] [ c ] [ -3 ] CONCAT   # → [ c b a ]  (逆順)
[ 1 ] [ 2 3 ] [ 4 ] [ 3 ] CONCAT  # → [ 1 2 3 4 ]

a b c .. CONCAT                # → [ a b c ]  (全体を連結)
a b c [ 2 ] .. CONCAT          # → a [ b c ]  (2個だけ連結)

## 注意
- ベクタでない要素も単独要素として含まれます
- 最初のベクタの括弧タイプが結果に適用されます"#.to_string(),

        "REVERSE" => r#"# REVERSE - 要素の順序を反転

## 機能
ベクタまたはスタックの要素順序を反転します。
「変化なしはエラー」原則により、要素が2個未満や回文の場合はエラー。

## 使用法（StackTopモード）
[ 要素... ] REVERSE
→ 要素順を反転した新しいベクタを返す

## 使用法（Stackモード）
要素... .. REVERSE
→ スタックの要素順を反転

## 使用例
[ a b c ] REVERSE      # → [ c b a ]
[ 1 2 3 4 ] REVERSE    # → [ 4 3 2 1 ]

a b c .. REVERSE    # → c b a

## エラーケース
[ 1 ] REVERSE          # エラー：1要素のみ（変化なし）
[ a b a ] REVERSE      # エラー：回文（変化なし）
[ ] REVERSE            # エラー：空ベクタ（変化なし）

## 注意
- 変化が生じない場合は必ずエラーになります"#.to_string(),

        "RANGE" => r#"# RANGE - 数値範囲を生成

## 機能
startからendまでの整数の範囲（等差数列）を生成します。
オプションでstep（増分）を指定可能です。

## 使用法（StackTopモード）
[ start ] [ end ] RANGE
→ 元の引数を保持し、範囲ベクタを追加

[ start ] [ end ] [ step ] RANGE
→ 元の引数を保持し、step間隔の範囲ベクタを追加

## 使用法（Stackモード）
start end .. RANGE
→ 範囲ベクタを生成

start end step .. RANGE
→ step間隔の範囲ベクタを生成

## 使用例
[ 0 ] [ 5 ] RANGE              # → [ 0 ] [ 5 ] [ 0 1 2 3 4 5 ]
[ 1 ] [ 10 ] RANGE             # → [ 1 ] [ 10 ] [ 1 2 3 4 5 6 7 8 9 10 ]
[ 0 ] [ 10 ] [ 2 ] RANGE       # → [ 0 ] [ 10 ] [ 2 ] [ 0 2 4 6 8 10 ]  (偶数)
[ 10 ] [ 0 ] [ -2 ] RANGE      # → [ 10 ] [ 0 ] [ -2 ] [ 10 8 6 4 2 0 ]  (降順)
[ 5 ] [ 5 ] RANGE              # → [ 5 ] [ 5 ] [ 5 ]  (単一要素)

0 5 .. RANGE                # → [ 0 1 2 3 4 5 ]
0 10 2 .. RANGE             # → [ 0 2 4 6 8 10 ]

## 活用例
# MAPと組み合わせてインデックス付き処理
[ 0 ] [ 4 ] RANGE '処理' MAP

# LENGTHと組み合わせて要素数分のループ
[ data ] LENGTH [ 1 ] - [ 0 ] SWAP RANGE

## エラーケース
[ 0 ] [ 10 ] [ 0 ] RANGE       # エラー：stepが0
[ 0 ] [ 10 ] [ -1 ] RANGE      # エラー：無限シーケンス（start < end だが step < 0）
[ 10 ] [ 0 ] [ 1 ] RANGE       # エラー：無限シーケンス（start > end だが step > 0）

## 注意
- endの値は範囲に含まれます（inclusive）
- stepのデフォルトは自動判定（start <= end なら 1、そうでなければ -1）
- 整数のみサポート"#.to_string(),

        // ============================================================================
        // ソート
        // ============================================================================

        "SORT" => r#"# SORT - ベクタの要素を昇順に並べ替える

## 機能
ベクタまたはスタック内の数値を昇順にソートします。
Ajisaiでは全ての数値が内部的に分数として表現されているため、
整数・分数・混在データのいずれも正確にソートできます。

## 使用法（StackTopモード）
[ 数値... ] SORT
→ 昇順にソートされたベクタを返す

## 使用法（Stackモード）
数値... .. SORT
→ スタック全体を昇順にソート

## 使用例
# 整数のソート
[ 32 8 2 18 ] SORT         # → [ 2 8 18 32 ]

# 分数のソート
[ 1/2 1/3 2/3 ] SORT       # → [ 1/3 1/2 2/3 ]

# 混在もOK
[ 3 1/2 2 1/4 ] SORT       # → [ 1/4 1/2 2 3 ]

# Stackモード
64 25 12 22 11 .. SORT     # スタック全体が昇順に

## エラーケース
[ 'a' 'b' ] SORT           # エラー：数値以外を含む
[ 1 ] SORT                 # エラー：1要素のみ（変化なし）
[ 1 2 3 ] SORT             # エラー：既にソート済み（変化なし）
[ 1 1 1 ] SORT             # エラー：全要素が同じ（変化なし）

## 注意
- 数値（整数・分数）のみをソート対象とします
- 「変化なしはエラー」原則により、ソート前後で変化がない場合はエラー
- 負の数も正しくソートされます"#.to_string(),

        // ============================================================================
        // 型変換
        // ============================================================================

        "STR" => r#"# STR - 文字列に変換

## 機能
任意の型を文字列表現に変換します。
同型変換（String → String）はエラーとなります。

## 使用法
[ value ] STR
→ 文字列に変換された値

## 使用例
[ 42 ] STR                       # → [ '42' ]
[ 1/3 ] STR                      # → [ '1/3' ]
[ TRUE ] STR                     # → [ 'TRUE' ]
[ FALSE ] STR                    # → [ 'FALSE' ]
[ nil ] STR                      # → [ 'nil' ]
[ [ 1 2 3 ] ] STR                # → [ '1 2 3' ]

## エラーケース
[ 'text' ] STR                   # エラー：同型変換（String → String）

## 注意
- StackTopモードのみサポート
- ベクトルはスペース区切りで平坦化されます"#.to_string(),

        "NUM" => r#"# NUM - 数値に変換

## 機能
文字列または真偽値を数値に変換します。
文字列の場合、パース失敗時はエラーとなります。

## 使用法
[ 'string' ] NUM
→ 数値に変換された値

[ boolean ] NUM
→ 数値に変換された値（TRUE → 1、FALSE → 0）

## 使用例
[ '42' ] NUM                     # → [ 42 ]
[ '1/3' ] NUM                    # → [ 1/3 ]
[ '3.14' ] NUM                   # → [ 157/50 ]（分数として正確に）
[ '1.5e2' ] NUM                  # → [ 150 ]
[ TRUE ] NUM                     # → [ 1 ]
[ FALSE ] NUM                    # → [ 0 ]

## エラーケース
[ 'hello' ] NUM                  # エラー：数値にパース不可
[ 42 ] NUM                       # エラー：同型変換（Number → Number）
[ nil ] NUM                      # エラー：Nilは数値に変換不可

## 注意
- String型またはBoolean型を受け付けます
- 小数は分数に変換されます（丸め誤差なし）
- 真偽値はTRUE → 1、FALSE → 0に変換されます（分数として1/1、0/1）"#.to_string(),

        "BOOL" => r#"# BOOL - 真偽値に変換

## 機能
文字列または数値を真偽値に変換します。
文字列の場合、"TRUE"/"FALSE"、"1"/"0"、"真"/"偽"を受け付けます。
数値の場合、1または0のみを受け付けます。

## 使用法
[ 'string' ] BOOL
→ 真偽値に変換された値

[ number ] BOOL
→ 真偽値に変換された値（1 → TRUE、0 → FALSE）

## 使用例
[ 'TRUE' ] BOOL                  # → [ TRUE ]
[ 'FALSE' ] BOOL                 # → [ FALSE ]
[ 'true' ] BOOL                  # → [ TRUE ]（大小文字無視）
[ 'false' ] BOOL                 # → [ FALSE ]
[ '1' ] BOOL                     # → [ TRUE ]
[ '0' ] BOOL                     # → [ FALSE ]
[ '真' ] BOOL                    # → [ TRUE ]
[ '偽' ] BOOL                    # → [ FALSE ]
[ 1 ] BOOL                       # → [ TRUE ]
[ 0 ] BOOL                       # → [ FALSE ]

## エラーケース
[ 'hello' ] BOOL                 # エラー：真偽値として認識不可
[ 2 ] BOOL                       # エラー：1または0以外の数値
[ TRUE ] BOOL                    # エラー：同型変換（Boolean → Boolean）
[ nil ] BOOL                     # エラー：Nilは真偽値に変換不可

## 注意
- String型またはNumber型を受け付けます
- 文字列の'TRUE'/'FALSE'は大文字小文字を区別しません
- 数値は1（1/1）または0（0/1）のみ有効です"#.to_string(),

        "NIL" => r#"# NIL - Nilに変換

## 機能
文字列をNilにパースします。
"nil"のみ受け付けます（大小文字無視）。

## 使用法
[ 'string' ] NIL
→ Nilに変換された値

## 使用例
[ 'nil' ] NIL                    # → [ nil ]
[ 'NIL' ] NIL                    # → [ nil ]（大小文字無視）
[ 'Nil' ] NIL                    # → [ nil ]

## エラーケース
[ 'hello' ] NIL                  # エラー：'nil'でない文字列
[ '0' ] NIL                      # エラー：'nil'でない文字列
[ TRUE ] NIL                     # エラー：Booleanは変換不可
[ 42 ] NIL                       # エラー：Numberは変換不可
[ nil ] NIL                      # エラー：同型変換（Nil → Nil）

## 注意
- String型のみ受け付けます
- 大文字小文字は区別しません
- Boolean型、Number型、Nil型への適用はエラーになります"#.to_string(),

        "CHARS" => r#"# CHARS - 文字列を文字ベクタに分解

## 機能
文字列を1文字ずつの文字列ベクタに分解します。
UTF-8マルチバイト文字（日本語など）も正しく処理されます。

## 使用法（StackTopモード）
[ 'string' ] CHARS
→ 文字ベクタ

## 使用法（Stackモード）
str1 str2 ... .. CHARS
→ 各文字列を文字ベクタに変換

## 使用例
[ 'hello' ] CHARS                # → [ 'h' 'e' 'l' 'l' 'o' ]
[ '日本語' ] CHARS               # → [ '日' '本' '語' ]
[ 'a' ] CHARS                    # → [ 'a' ]

'abc' 'xyz' .. CHARS             # → [ 'a' 'b' 'c' ] [ 'x' 'y' 'z' ]

## 活用例（既存ワードとの組み合わせ）
# 文字列を反転
[ 'hello' ] CHARS REVERSE JOIN   # → [ 'olleh' ]

# 文字列の長さ
[ 'hello' ] CHARS LENGTH         # → [ 'h' 'e' 'l' 'l' 'o' ] [ 5 ]

# 特定位置の文字を取得
[ 'hello' ] CHARS [ 1 ] GET      # → [ ... ] [ 'e' ]

# 部分文字列
[ 'hello' ] CHARS [ 3 ] TAKE JOIN  # → [ 'hel' ]

## エラーケース
[ '' ] CHARS                     # エラー: 空文字列
[ 42 ] CHARS                     # エラー: 数値型
[ [ 'a' ] ] CHARS                # エラー: ベクタ型

## 注意
- String型のみ受け付けます
- 空文字列はエラー（"No change is an error"原則）
- JOINワードで元の文字列に戻せます"#.to_string(),

        "JOIN" => r#"# JOIN - 文字列ベクタを連結

## 機能
文字列のベクタを連結して単一の文字列にします。
CHARSワードの逆操作として使用できます。

## 使用法（StackTopモード）
[ str1 str2 ... ] JOIN
→ 連結された文字列

## 使用法（Stackモード）
vec1 vec2 ... .. JOIN
→ 各ベクタを連結した文字列に変換

## 使用例
[ 'h' 'e' 'l' 'l' 'o' ] JOIN     # → [ 'hello' ]
[ 'hel' 'lo' ] JOIN              # → [ 'hello' ]
[ '日' '本' '語' ] JOIN          # → [ '日本語' ]
[ 'a' ] JOIN                     # → [ 'a' ]

[ 'a' 'b' ] [ 'x' 'y' ] .. JOIN  # → [ 'ab' ] [ 'xy' ]

## 活用例（CHARSとの組み合わせ）
# 文字列を反転
[ 'hello' ] CHARS REVERSE JOIN   # → [ 'olleh' ]

# 特定文字を除去（フィルタ）
# IS_NOTSPACEを定義済みとして
[ 'a b c' ] CHARS 'IS_NOTSPACE' FILTER JOIN  # → [ 'abc' ]

# 文字を変換（MAP）
# UPPER_CHARを定義済みとして
[ 'hello' ] CHARS 'UPPER_CHAR' MAP JOIN  # → [ 'HELLO' ]

## エラーケース
[ ] JOIN                         # エラー: 空ベクタ
[ 1 2 3 ] JOIN                   # エラー: 数値を含む
[ 'a' 1 'b' ] JOIN               # エラー: 混在型

## 注意
- 全要素がString型である必要があります
- 空ベクタはエラー
- 数値や他の型を含むとエラー"#.to_string(),

        // ============================================================================
        // 日付時刻操作
        // ============================================================================

        "NOW" => r#"# NOW - 現在時刻取得

## 機能
現在のUnixタイムスタンプをDateTime型で取得します。
1970-01-01 00:00:00 UTCからの経過秒数をミリ秒精度の分数として保持し、
スタック表示では人間が読みやすい日時形式で表示されます。

## 使用法
NOW
→ 現在のタイムスタンプ（DateTime型）

## 使用例
NOW                              # → [ @2024-11-25 14:00:00.500 ]
# 表示は日時形式ですが、内部的には分数（1732531200500/1000）

NOW 'LOCAL' DATETIME             # → [ [ 2024 11 25 14 0 0 500/1000 ] ]
# DateTime型を日付時刻Vectorに変換

## 活用例
# 処理時間の計測
NOW                              # 開始時刻
'処理' '長い処理' DEF
長い処理                          # 何らかの処理
NOW                              # 終了時刻
-                                # 経過時間（秒、Number型で返る）

# タイムスタンプの記録
NOW '記録時刻' DEF

# 現在時刻を読みやすく表示
NOW 'LOCAL' DATETIME PRINT

## 注意
- DateTime型として返されます（表示は日時形式、内部は分数）
- ミリ秒精度で取得されます（分数として表現）
- タイムゾーンに依存しない絶対時刻（UTC基準）
- ブラウザのDate.now()を使用
- 算術演算（+、-など）では通常のNumber型と同様に計算可能"#.to_string(),

        "DATETIME" => r#"# DATETIME - 日付時刻Vectorに変換

## 機能
Unixタイムスタンプを指定したタイムゾーンでの
日付時刻Vector [年 月 日 時 分 秒] に変換します。
サブ秒精度がある場合は7番目の要素として含まれます。

**重要**: タイムゾーン指定が必須です。これにより「どのタイムゾーンか」
を常に意識することが強制され、タイムゾーン関連のバグを防ぎます。

## 使用法
[ timestamp ] 'timezone' DATETIME
→ 日付時刻Vector

## タイムゾーン指定
- 'LOCAL': ブラウザのローカルタイムゾーン（推奨）
- 将来的に他のタイムゾーン（'UTC', 'Asia/Tokyo'など）もサポート予定

## 使用例
[ 1732531200 ] 'LOCAL' DATETIME
# → [ [ 2024 11 25 14 0 0 ] ]
# ブラウザのタイムゾーンで変換

[ 1732531200 1/2 + ] 'LOCAL' DATETIME
# → [ [ 2024 11 25 14 0 0 1/2 ] ]
# サブ秒精度（0.5秒）も保持

[ 0 ] 'LOCAL' DATETIME
# → [ [ 1970 1 1 9 0 0 ] ]
# Unixエポック（Asia/Tokyoの場合は9時間のオフセット）

## 活用例
# 現在時刻を読みやすい形式で表示
NOW 'LOCAL' DATETIME PRINT

# タイムスタンプから年を取得
[ 1732531200 ] 'LOCAL' DATETIME [ 0 ] GET
# → [ [ 2024 11 25 14 0 0 ] ] [ 2024 ]

# 月だけを取得
[ 1732531200 ] 'LOCAL' DATETIME [ 1 ] GET
# → [ [ 2024 11 25 14 0 0 ] ] [ 11 ]

## Vector形式
- [年 月 日 時 分 秒]：通常の形式（サブ秒なし）
- [年 月 日 時 分 秒 サブ秒]：ミリ秒精度などを含む場合

## 設計思想
BigQuery SQLの「タイムゾーンは変換パラメータ」という思想を採用。
タイムゾーン指定を省略可能にすると、どのタイムゾーンかの意識が
薄れてしまうため、明示的な指定を必須としています。

## 注意
- タイムゾーン指定は必須（省略不可）
- 月は1-12（1月=1、12月=12）
- 日は1-31
- 時は0-23
- 分・秒は0-59
- サブ秒は分数（例：500/1000 = 0.5秒）"#.to_string(),

        "TIMESTAMP" => r#"# TIMESTAMP - DateTime型に変換

## 機能
指定したタイムゾーンでの日付時刻Vector
[年 月 日 時 分 秒] をDateTime型に変換します。
DateTime型は内部的にはUnixタイムスタンプ（分数）ですが、
スタック表示では人間が読みやすい日時形式で表示されます。
実在しない日時（2023-13-32など）はエラーになります。

**重要**: タイムゾーン指定が必須です。これにより「どのタイムゾーンか」
を常に意識することが強制され、タイムゾーン関連のバグを防ぎます。

## 使用法
[ [ 年 月 日 時 分 秒 ] ] 'timezone' TIMESTAMP
→ DateTime型（表示は日時形式、内部は分数）

[ [ 年 月 日 時 分 秒 サブ秒 ] ] 'timezone' TIMESTAMP
→ DateTime型（サブ秒精度を含む）

## タイムゾーン指定
- 'LOCAL': ブラウザのローカルタイムゾーン（推奨）
- 将来的に他のタイムゾーン（'UTC', 'Asia/Tokyo'など）もサポート予定

## 使用例
[ [ 2024 11 25 14 0 0 ] ] 'LOCAL' TIMESTAMP
# → [ @2024-11-25 14:00:00 ]
# ブラウザのタイムゾーンで変換（内部は1732531200）

[ [ 2024 11 25 14 0 0 1/2 ] ] 'LOCAL' TIMESTAMP
# → [ @2024-11-25 14:00:00.500 ]
# サブ秒精度（0.5秒）を含む（内部は3465062401/2）

[ [ 1970 1 1 0 0 0 ] ] 'LOCAL' TIMESTAMP
# → [ @1969-12-31 15:00:00 ]
# ローカル時刻の1970-01-01 00:00:00（表示はUTC変換後）

## エラーケース
[ [ 2023 13 32 0 0 0 ] ] 'LOCAL' TIMESTAMP
# エラー：実在しない日付（13月32日）

[ [ 2024 2 30 0 0 0 ] ] 'LOCAL' TIMESTAMP
# エラー：2024年2月30日は存在しない

[ [ 2024 11 25 25 0 0 ] ] 'LOCAL' TIMESTAMP
# エラー：25時は存在しない

## 活用例
# 特定の日時のDateTime型を取得
[ [ 2025 1 1 0 0 0 ] ] 'LOCAL' TIMESTAMP
# → [ @2025-01-01 00:00:00 ]

# 日付の比較（DateTime型同士）
[ [ 2024 12 25 0 0 0 ] ] 'LOCAL' TIMESTAMP
[ [ 2024 12 31 0 0 0 ] ] 'LOCAL' TIMESTAMP
<
# → [ TRUE ]（12/25 < 12/31、内部的には分数として比較）

# 往復変換でバリデーション
[ [ 2024 2 29 0 0 0 ] ] 'LOCAL' TIMESTAMP 'LOCAL' DATETIME
# → [ [ 2024 2 29 0 0 0 ] ]（2024年はうるう年なので有効）

# 算術演算も可能（秒単位で加減算）
[ [ 2024 11 25 14 0 0 ] ] 'LOCAL' TIMESTAMP
[ 3600 ] +
# → [ @2024-11-25 15:00:00 ]（1時間=3600秒を加算）

## Vector形式
- [年 月 日 時 分 秒]：必須（6要素）
- [年 月 日 時 分 秒 サブ秒]：オプション（7要素）

## 設計思想
BigQuery SQLの「タイムゾーンは変換パラメータ」という思想を採用。
タイムゾーン指定を省略可能にすると、どのタイムゾーンかの意識が
薄れてしまうため、明示的な指定を必須としています。

## 注意
- DateTime型として返されます（表示は日時形式、内部は分数）
- タイムゾーン指定は必須（省略不可）
- 最初の6要素（年月日時分秒）は整数である必要があります
- サブ秒（7番目の要素）のみ分数可
- 実在しない日時は自動補正されずエラーになります
- 算術演算（+、-など）では通常のNumber型と同様に計算可能
- JavaScriptのDateオブジェクトで検証されます"#.to_string(),

        // ============================================================================
        // 算術演算
        // ============================================================================

        "+" => r#"# + - 加算

## 機能（StackTopモード）
2つのベクタの要素ごとの加算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に加算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] +
→ 要素ごとに加算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. +
→ 指定個数の要素を加算した結果

## 使用例（StackTopモード）
[ 1 2 3 ] [ 4 5 6 ] +      # → [ 5 7 9 ]  (要素ごと)
[ 1 2 3 ] [ 10 ] +         # → [ 11 12 13 ]  (ブロードキャスト)
[ 5 ] [ 1 2 3 ] +          # → [ 6 7 8 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 1 ] [ 2 ] [ 3 ] [ 3 ] .. +   # → [ 6 ]  (1+2+3)
[ 10 ] [ 5 ] [ 2 ] .. +        # → [ 12 ]  (10+5、デフォルト2個)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[0]との加算）はエラー"#.to_string(),

        "-" => r#"# - - 減算

## 機能（StackTopモード）
2つのベクタの要素ごとの減算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に減算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] -
→ 要素ごとに減算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. -
→ 指定個数の要素を減算した結果

## 使用例（StackTopモード）
[ 5 7 9 ] [ 1 2 3 ] -      # → [ 4 5 6 ]  (要素ごと)
[ 10 20 30 ] [ 5 ] -       # → [ 5 15 25 ]  (ブロードキャスト)
[ 100 ] [ 1 2 3 ] -        # → [ 99 98 97 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 10 ] [ 3 ] [ 2 ] [ 3 ] .. -  # → [ 5 ]  (10-3-2)
[ 100 ] [ 25 ] [ 2 ] .. -      # → [ 75 ]  (100-25)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[0]との減算）はエラー"#.to_string(),

        "*" => r#"# * - 乗算

## 機能（StackTopモード）
2つのベクタの要素ごとの乗算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に乗算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] *
→ 要素ごとに乗算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. *
→ 指定個数の要素を乗算した結果

## 使用例（StackTopモード）
[ 1 2 3 ] [ 4 5 6 ] *      # → [ 4 10 18 ]  (要素ごと)
[ 1 2 3 ] [ 10 ] *         # → [ 10 20 30 ]  (ブロードキャスト)
[ 5 ] [ 2 3 4 ] *          # → [ 10 15 20 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 2 ] [ 3 ] [ 4 ] [ 3 ] .. *   # → [ 24 ]  (2*3*4)
[ 5 ] [ 6 ] [ 2 ] .. *         # → [ 30 ]  (5*6)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 演算結果が入力と同じ場合（例：[1]との乗算）はエラー"#.to_string(),

        "/" => r#"# / - 除算

## 機能（StackTopモード）
2つのベクタの要素ごとの除算を行います。
片方が単一要素の場合、ブロードキャスト（全要素に適用）されます。
結果は分数として正確に保持されます。

## 機能（Stackモード）
スタックから指定個数の要素を取得し、左から右へ順に除算します。

## 使用法（StackTopモード）
[ 要素... ] [ 要素... ] /
→ 要素ごとに除算した新しいベクタ

## 使用法（Stackモード）
要素... [ 個数 ] .. /
→ 指定個数の要素を除算した結果

## 使用例（StackTopモード）
[ 10 20 30 ] [ 2 4 5 ] /   # → [ 5 5 6 ]  (要素ごと)
[ 10 20 30 ] [ 10 ] /      # → [ 1 2 3 ]  (ブロードキャスト)
[ 100 ] [ 2 4 5 ] /        # → [ 50 25 20 ]  (逆向きブロードキャスト)

## 使用例（Stackモード）
[ 100 ] [ 2 ] [ 5 ] [ 3 ] .. /  # → [ 10 ]  (100/2/5)
[ 20 ] [ 4 ] [ 2 ] .. /         # → [ 5 ]  (20/4)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 0での除算はエラー
- 演算結果が入力と同じ場合（例：[1]での除算）はエラー"#.to_string(),

        // ============================================================================
        // 比較演算
        // ============================================================================

        "=" => r#"# = - 等価比較

## 機能（StackTopモード）
2つの値を比較し、完全に等しいかどうかを判定します。
あらゆる型の値を比較可能（Number、String、Boolean、Vector、Nil）。

## 機能（Stackモード）
N個の要素を順に比較し、全て等しいかを判定します。

## 使用法
[ value1 ] [ value2 ] =
→ 等しければ [true]、異なれば [false]

## 使用例（StackTopモード）
[ 3 ] [ 3 ] =              # → [ true ]
[ 3 ] [ 5 ] =              # → [ false ]
[ 'hello' ] [ 'hello' ] =  # → [ true ]
[ 1 2 ] [ 1 2 ] =          # → [ true ]  (ベクタ全体を比較)
[ 1 2 ] [ 1 3 ] =          # → [ false ]

## 使用例（Stackモード）
[ 3 ] [ 3 ] [ 3 ] [ 3 ] .. =    # → [ true ]  (全て等しい)
[ 1 ] [ 2 ] [ 1 ] [ 3 ] .. =    # → [ false ] (1≠2)

## 注意
- ベクタ全体を1つの値として比較します
- 要素ごとの比較ではありません"#.to_string(),

        "<" => r#"# < - 小なり比較

## 機能
2つのベクタの要素ごとに「左 < 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] <
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 1 2 3 ] [ 2 2 2 ] <      # → [ true false false ]
[ 1 2 3 ] [ 3 ] <          # → [ true true false ]  (ブロードキャスト)
[ 5 ] [ 1 2 3 4 5 ] <      # → [ false false false false false ]

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        "<=" => r#"# <= - 小なりイコール比較

## 機能
2つのベクタの要素ごとに「左 <= 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] <=
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 1 2 3 ] [ 2 2 2 ] <=     # → [ true true false ]
[ 1 2 3 ] [ 3 ] <=         # → [ true true true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        ">" => r#"# > - 大なり比較

## 機能
2つのベクタの要素ごとに「左 > 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] >
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 3 2 1 ] [ 2 2 2 ] >      # → [ true false false ]
[ 5 4 3 ] [ 3 ] >          # → [ true true false ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        ">=" => r#"# >= - 大なりイコール比較

## 機能
2つのベクタの要素ごとに「左 >= 右」を比較します。
要素数が等しい場合は要素ごとに比較、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] >=
→ 各要素の比較結果（true/false）のベクタ

## 使用例
[ 3 2 1 ] [ 2 2 2 ] >=     # → [ true true false ]
[ 5 4 3 ] [ 3 ] >=         # → [ true true true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー"#.to_string(),

        // ============================================================================
        // 論理演算
        // ============================================================================

        "AND" => r#"# AND - 論理積

## 機能
2つのベクタの要素ごとに論理積（AND）を計算します。
要素数が等しい場合は要素ごとに演算、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] AND
→ 各要素の論理積のベクタ

## 使用例
[ true true false false ] [ true false true false ] AND
# → [ true false false false ]

[ true false true ] [ true ] AND
# → [ true false true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 要素はboolean型である必要があります"#.to_string(),

        "OR" => r#"# OR - 論理和

## 機能
2つのベクタの要素ごとに論理和（OR）を計算します。
要素数が等しい場合は要素ごとに演算、片方が単一要素の場合はブロードキャスト。

## 使用法
[ 要素... ] [ 要素... ] OR
→ 各要素の論理和のベクタ

## 使用例
[ true true false false ] [ true false true false ] OR
# → [ true true true false ]

[ true false true ] [ false ] OR
# → [ true false true ]  (ブロードキャスト)

## 注意
- ベクタの長さが異なる場合（ブロードキャスト以外）はエラー
- 要素はboolean型である必要があります"#.to_string(),

        "NOT" => r#"# NOT - 論理否定

## 機能
ベクタの各要素の論理否定（NOT）を計算します。

## 使用法
[ 要素... ] NOT
→ 各要素を否定したベクタ

## 使用例
[ true false true ] NOT    # → [ false true false ]
[ false ] NOT              # → [ true ]

## 注意
- 要素はboolean型である必要があります"#.to_string(),

        // ============================================================================
        // 制御構造
        // ============================================================================

        ":" => r#"# : - ガード区切り（条件分岐）

## 機能
条件による分岐を実現します。
「条件 : アクション : 条件 : アクション : デフォルト」の形式で使用します。

## 使用法
条件1 : アクション1 : 条件2 : アクション2 : ... : デフォルトアクション

## 動作
- 左から順に条件を評価
- 最初にtrueになった条件のアクションを実行
- すべての条件がfalseの場合、デフォルトアクションを実行

## 使用例
# 値が正か負かゼロかを判定
[ 5 ] [ 0 ] > : 'positive' : [ 5 ] [ 0 ] < : 'negative' : 'zero'
# → 'positive' (5 > 0がtrue)

# 単純なif-else
[ x ] [ 10 ] > : '大きい' : '小さいか等しい'

## 注意
- 条件は真偽値（true/false）を返す式である必要があります
- コロンの数は奇数個になります（条件:アクション:条件:アクション:デフォルト）"#.to_string(),

        // ============================================================================
        // 高階関数
        // ============================================================================

        "MAP" => r#"# MAP - 各要素に関数を適用

## 機能
ベクタまたはスタックの各要素に対して、指定したワードを適用します。

## 使用法（StackTopモード）
[ 要素... ] 'WORD' MAP
→ 各要素にWORDを適用した結果のベクタ

## 使用法（Stackモード）
要素... [ 個数 ] 'WORD' .. MAP
→ 指定個数の要素にWORDを適用

## 使用例
[ 1 2 3 4 ] '[ 2 ] *' MAP
# → [ 2 4 6 8 ]  (各要素を2倍)

[ 1 2 3 ] '[ 1 ] +' MAP
# → [ 2 3 4 ]  (各要素に1を加算)

# カスタムワードを使用
[ '[ 2 ] * [ 1 ] +' ] 'DOUBLE_PLUS_ONE' DEF
[ 1 2 3 ] 'DOUBLE_PLUS_ONE' MAP
# → [ 3 5 7 ]  (各要素を2倍して1を足す)

## 注意
- ワード名はシングルクォート文字列で指定
- 各要素に対して独立して実行されます"#.to_string(),

        "FILTER" => r#"# FILTER - 条件に合う要素を抽出

## 機能
ベクタの各要素に対して条件ワードを適用し、
trueを返した要素のみを残します。

## 使用法
[ 要素... ] 'WORD' FILTER
→ 条件を満たす要素のみのベクタ

## 使用例
[ 1 2 3 4 5 6 ] '[ 2 ] [ 0 ] = NOT' FILTER
# → [ 1 3 5 ]  (奇数のみ抽出)

[ 10 5 20 3 15 ] '[ 10 ] >' FILTER
# → [ 20 15 ]  (10より大きい要素)

# カスタムワードを使用
[ '[ 5 ] >' ] 'IS_LARGE' DEF
[ 1 3 8 2 7 ] 'IS_LARGE' FILTER
# → [ 8 7 ]  (5より大きい要素)

## 注意
- ワード名はシングルクォート文字列で指定
- 条件ワードはtrue/falseを返す必要があります"#.to_string(),

        "FOLD" => r#"# FOLD - 初期値付き畳み込み

## 機能
ベクタまたはスタック上の要素を、初期値から始めて二項演算ワードで畳み込み、
単一の結果に集約します。REDUCEと異なり、初期値を明示的に指定できます。

## REDUCEとの違い
- REDUCE: 最初の要素を初期値として使用、空ベクタでエラー
- FOLD: 初期値を明示的に指定、空ベクタでは初期値をそのまま返す

## 畳み込みの順序
左から右へ順番に演算を適用します：
[ a b c ] [init] 'OP' FOLD = ((init OP a) OP b) OP c

## 使用法（StackTopモード）
[ 要素... ] [ 初期値 ] 'ワード名' FOLD
→ 畳み込んだ結果を単一要素ベクタとして返す

## 使用法（Stackモード）
要素... [ 個数 ] [ 初期値 ] 'ワード名' .. FOLD
→ スタック上のN個の要素を初期値から畳み込む

## 使用例
[ 1 2 3 4 ] [ 0 ] '+' FOLD     # → [ 10 ]  (0+1+2+3+4)
[ 1 2 3 4 ] [ 1 ] '*' FOLD     # → [ 24 ]  (1*1*2*3*4)
[ 1 2 3 ] [ 10 ] '-' FOLD      # → [ 4 ]   (10-1-2-3)

# 空ベクタの場合は初期値がそのまま返る
[ ] [ 42 ] '+' FOLD            # → [ 42 ]

# 文字列連結（カスタムワード使用）
[ '[ 2 ] CONCAT' ] 'STRCAT' DEF
[ 'a' 'b' 'c' ] [ '' ] 'STRCAT' FOLD   # → [ 'abc' ]

# Stackモード
[1] [2] [3] [3] [0] '+' .. FOLD   # → [ 6 ]  (0+1+2+3)

## 畳み込みの動作（詳細）
[ 1 2 3 ] [ 0 ] '+' FOLD の処理順序：
1. acc = 0 (初期値)
2. acc = acc + 1 = 1
3. acc = acc + 2 = 3
4. acc = acc + 3 = 6
5. 結果: [ 6 ]

## 注意
- 空のベクタに対しては初期値をそのまま返す（エラーにならない）
- 単一要素のベクタに対しても正常動作（init OP x を計算）
- 適用するワードは2つの単一要素ベクタを受け取り、1つを返す必要がある
- 組み込みワード（+, -, *, /）とカスタムワードの両方が使用可能"#.to_string(),

        "UNFOLD" => r#"# UNFOLD - 状態からベクタを生成

## 機能
初期状態から始めて、ワードを繰り返し適用してベクタを生成します。
Haskellの unfoldr に相当する高階関数です。

## 使用法（StackTopモード）
[ 初期状態 ] 'ワード名' UNFOLD
→ 生成された要素のベクタを返す

## 使用法（Stackモード）
[ 初期状態 ] 'ワード名' .. UNFOLD
→ 生成された要素をスタックに直接展開

## ワードの仕様
ワードは以下のいずれかを返す必要があります：
- [ 要素 次の状態 ] : 要素を生成し、次の状態で続行
- [ 要素 NIL ] : 要素を生成し、終了
- NIL : 即座に終了（要素を生成しない）

## 使用例

# 1から5までの数列を生成
[ ': [0] [0] GET [5] >
: NIL
: [0] [0] GET [0] [0] GET [1] +' ] 'RANGE5' DEF
[ 1 ] 'RANGE5' UNFOLD    # → [ 1 2 3 4 5 ]

# 常に同じ値を10個生成
[ ': [0] [1] GET [10] >=
: NIL
: [42] [0] [1] GET [1] +' ] 'TEN_42S' DEF
[ 42 0 ] 'TEN_42S' UNFOLD    # → [ 42 42 42 42 42 42 42 42 42 42 ]

# 空ベクタの生成（即座にNILを返す）
[ ': NIL' ] 'STOPNOW' DEF
[ 1 ] 'STOPNOW' UNFOLD    # → [ ]

## UNFOLDの動作（詳細）
[ 1 ] 'RANGE5' UNFOLD の処理順序：
1. state = [ 1 ]
2. 'RANGE5'を実行 → [ 1 2 ] (要素1, 次の状態2)
3. state = [ 2 ]
4. 'RANGE5'を実行 → [ 2 3 ]
5. state = [ 3 ]
6. 'RANGE5'を実行 → [ 3 4 ]
7. state = [ 4 ]
8. 'RANGE5'を実行 → [ 4 5 ]
9. state = [ 5 ]
10. 'RANGE5'を実行 → NIL (5 > 5 なので終了)
11. 結果: [ 1 2 3 4 5 ]

## 注意
- 最大10000回のイテレーションでエラー（無限ループ防止）
- 空のベクタを生成することも可能（即座にNILを返す場合）
- ワードが不正な値を返した場合はエラー
- FOLDの逆操作に相当（FOLDは畳み込み、UNFOLDは展開）"#.to_string(),

        // ============================================================================
        // 入出力
        // ============================================================================

        "PRINT" => r#"# PRINT - 要素を出力

## 機能
スタックトップの要素を出力バッファに書き込みます。
要素はスタックから除去されます。

## 使用法
要素 PRINT
→ 要素を出力し、スタックから削除

## 使用例
[ 42 ] PRINT              # 出力: 42
'Hello' PRINT             # 出力: Hello
[ 1 2 3 ] PRINT           # 出力: [1 2 3]

# 複数の値を出力
[ 1 ] [ 2 ] [ 3 ]
PRINT PRINT PRINT         # 出力: 1 2 3

## 注意
- 出力後、要素はスタックから削除されます
- 出力フォーマットは要素の型によって自動的に決定されます"#.to_string(),

        "AUDIO" => r#"# AUDIO - ベクタ要素を音声として再生

## 機能
ベクタの各要素を音声として再生します。
分数は分子と分母をそれぞれ周波数（Hz）として同時に鳴らします（DTMF方式）。

## 使用法
[ 周波数1 周波数2 ... ] AUDIO
→ 各周波数を順番に再生

## 分数の解釈
- 整数（分母が1）: 単音として再生
  [ 440 ] AUDIO → 440Hz を再生
- 分数: 分子と分母を同時に再生（和音）
  [ 1209/697 ] AUDIO → 1209Hz と 697Hz を同時再生（DTMF「1」）

## 特殊な要素
- NIL: 休符（無音）
  [ 440 NIL 880 ] AUDIO → 440Hz → 無音 → 880Hz
- 文字列: Outputエリアに出力（音ではない）
  [ 'Hello' ] AUDIO → "Hello" を出力

## 時間軸の入れ子（順次再生）
ネストされたベクタは全て順次再生として解釈されます。
- 1次元: ノート（各0.5秒）
- 2次元: フレーズ（ノートの集まり）
- 3次元: セクション（フレーズの集まり）
- 4次元: 楽曲（セクションの集まり）

[ [ 440 880 ] [ 550 660 ] ] AUDIO
→ 440Hz → 880Hz → 550Hz → 660Hz（全て順次再生）

## オペレーションターゲット
- .AUDIO（デフォルト）: スタックトップを1トラックとして順次再生
- ..AUDIO: スタック全体の各要素を複数トラックとして同時再生
  [ 440 880 ] [ 550 660 ] .. AUDIO
  → トラック1（440Hz→880Hz）とトラック2（550Hz→660Hz）を同時再生

## DTMF信号の例
[ 1209/697 ] AUDIO   # 「1」
[ 1336/697 ] AUDIO   # 「2」
[ 1477/697 ] AUDIO   # 「3」
[ 1209/770 ] AUDIO   # 「4」
[ 1336/770 ] AUDIO   # 「5」
[ 1477/770 ] AUDIO   # 「6」
[ 1209/852 ] AUDIO   # 「7」
[ 1336/852 ] AUDIO   # 「8」
[ 1477/852 ] AUDIO   # 「9」
[ 1336/941 ] AUDIO   # 「0」

## 注意
- 入力ベクタはスタックから消費されます
- 周波数は正の数値である必要があります"#.to_string(),

        // ============================================================================
        // ワード管理
        // ============================================================================

        "DEF" => r#"# DEF - カスタムワードを定義

## 機能
新しいカスタムワードを定義し、辞書に登録します。

## 使用法
[ '定義内容' ] 'NAME' DEF               # 説明なし
[ '定義内容' ] 'NAME' '説明' DEF       # 説明あり

## 使用例
# 単純なワード定義
[ '[ 2 ] *' ] 'DOUBLE' DEF
[ 5 ] DOUBLE                # → [ 10 ]

# 複数行の定義（改行を含む）
[ '[ 1 ] +
  [ 2 ] *' ] 'INC_AND_DOUBLE' DEF
[ 5 ] INC_AND_DOUBLE        # → [ 12 ]  ((5+1)*2)

# 説明付きの定義
[ '[ 3 ] *' ] 'TRIPLE' '値を3倍にする' DEF
'TRIPLE' ?                  # 説明が表示される

## 注意
- ワード名は自動的に大文字に変換されます
- 組み込みワードは上書きできません
- 既存のカスタムワードは上書きされます
- 定義内容はシングルクォート文字列で指定します"#.to_string(),

        "DEL" => r#"# DEL - カスタムワードを削除

## 機能
辞書からカスタムワードを削除します。

## 使用法
'NAME' DEL
→ 指定したワードを辞書から削除

## 使用例
# ワードを定義して削除
[ '[ 2 ] *' ] 'DOUBLE' DEF
'DOUBLE' DEL                # DOUBLEが削除される

# 削除後は使用不可
[ 5 ] DOUBLE                # エラー: Unknown word

## 注意
- 組み込みワードは削除できません
- 存在しないワードを削除しようとするとエラー
- ワード名は自動的に大文字に変換されます"#.to_string(),

        "?" => r#"# ? - ワード定義を参照

## 機能
ワードの定義や説明をInputエリアに呼び出します。

## 使用法
'NAME' ?
→ ワードの定義をInputエリアに読み込み

## 動作
【組み込みワードの場合】
- 詳細な説明、使用法、使用例が表示されます
- 機能、構文、注意事項などの情報が含まれます

【カスタムワードの場合】
- 定義時の記述がそのまま表示されます
- 改行、#コメントなども含めて完全に再現されます
- DEF文として呼び出されるため、再定義が簡単です

## 使用例
'GET' ?                     # GETの詳細な説明が表示される
'DOUBLE' ?                  # DOUBLEの定義が表示される

# カスタムワードの定義を確認して修正
[ '[ 2 ] *' ] 'DOUBLE' DEF
'DOUBLE' ?                  # [ '[ 2 ] *' ] 'DOUBLE' DEF
# ↑ Inputエリアに読み込まれるので、編集して再定義可能

## 注意
- ワード名は自動的に大文字に変換されます
- 存在しないワードを参照するとエラー"#.to_string(),

        // ============================================================================
        // 入力支援
        // ============================================================================

        "'" => r#"# ' - シングルクォート挿入

## 機能
Inputエリアにシングルクォート(')を挿入します。
入力支援のための便利機能です。

## 使用法
ボタンをクリックすると、カーソル位置にシングルクォートが挿入されます。

## 使用例
キーボード入力: [  ]  →  ボタン「'」クリック  →  [ '' ]
（カーソルがクォートの間に配置されます）

## 注意
- これは実行可能なワードではなく、入力支援機能です"#.to_string(),

        "SCALAR" => r#"# SCALAR - 第1層ブラケット入力

## 機能
第1層（時間/スカラー）用のブラケット構造をInputエリアに挿入します。
オプションで繰り返し数を指定できます。

## 使用法
SCALAR           → [ ]
[ N ] SCALAR     → [ [ ] [ ] ... ] （N個）

## 使用例
SCALAR           # → [ ]
[ 2 ] SCALAR     # → [ [ ] [ ] ]
[ 3 ] SCALAR     # → [ [ ] [ ] [ ] ]

## 層構造
- 第0層: スタック（暗黙的）
- 第1層: 時間 ← SCALAR

## 注意
- これは入力支援機能です
- 繰り返し数は正の整数である必要があります"#.to_string(),

        "VECTOR" => r#"# VECTOR - 第2層ブラケット入力

## 機能
第2層（要素/ベクトル）用のブラケット構造をInputエリアに挿入します。
オプションで繰り返し数を指定できます。

## 使用法
VECTOR           → [ [ ] ]
[ N ] VECTOR     → [ [ [ ] ] [ [ ] ] ... ] （N個）

## 使用例
VECTOR           # → [ [ ] ]
[ 2 ] VECTOR     # → [ [ [ ] ] [ [ ] ] ]

## 層構造
- 第0層: スタック（暗黙的）
- 第1層: 時間
- 第2層: 要素 ← VECTOR

## 注意
- これは入力支援機能です
- 繰り返し数は正の整数である必要があります"#.to_string(),

        "MATRIX" => r#"# MATRIX - 第3層ブラケット入力

## 機能
第3層（行/行列）用のブラケット構造をInputエリアに挿入します。
オプションで繰り返し数を指定できます。

## 使用法
MATRIX           → [ [ [ ] ] ]
[ N ] MATRIX     → [ [ [ [ ] ] ] [ [ [ ] ] ] ... ] （N個）

## 使用例
MATRIX           # → [ [ [ ] ] ]
[ 2 ] MATRIX     # → [ [ [ [ ] ] ] [ [ [ ] ] ] ]

## 層構造
- 第0層: スタック（暗黙的）
- 第1層: 時間
- 第2層: 要素
- 第3層: 行 ← MATRIX

## 注意
- これは入力支援機能です
- 繰り返し数は正の整数である必要があります"#.to_string(),

        "TENSOR" => r#"# TENSOR - 第4層ブラケット入力

## 機能
第4層（列/テンソル）用のブラケット構造をInputエリアに挿入します。
オプションで繰り返し数を指定できます。

## 使用法
TENSOR           → [ [ [ [ ] ] ] ]
[ N ] TENSOR     → [ [ [ [ [ ] ] ] ] [ [ [ [ ] ] ] ] ... ] （N個）

## 使用例
TENSOR           # → [ [ [ [ ] ] ] ]
[ 2 ] TENSOR     # → [ [ [ [ [ ] ] ] ] [ [ [ [ ] ] ] ] ]

## 層構造（完全版）
- 第0層: スタック（暗黙的）
- 第1層: 時間
- 第2層: 要素
- 第3層: 行
- 第4層: 列 ← TENSOR

## 注意
- これは入力支援機能です
- Ajisaiは第0層（スタック）を含めて5層、ユーザーデータとしては4次元までをサポートします
- 繰り返し数は正の整数である必要があります"#.to_string(),

        "!" => r#"# ! - 強制実行演算子

## 機能
依存関係のあるカスタムワードの削除（DEL）や再定義（DEF）を許可します。
他のカスタムワードから参照されているワードを操作する際に使用します。

## 使用法
! 'WORDNAME' DEL     # 強制削除
! [ ': ...' ] 'WORDNAME' DEF  # 強制再定義

## 使用例
[ ': [ 2 ] *' ] 'DOUBLE' DEF
[ ': DOUBLE DOUBLE' ] 'QUAD' DEF

'DOUBLE' DEL           # Error: referenced by QUAD
! 'DOUBLE' DEL         # OK（警告付きで削除）

[ ': [ 3 ] *' ] 'DOUBLE' DEF     # Error: referenced by QUAD
! [ ': [ 3 ] *' ] 'DOUBLE' DEF   # OK（警告付きで再定義）

## 注意
- 組み込みワードには効果がありません（常にエラー）
- フラグは次のDEL/DEF実行後に自動リセットされます
- 依存関係のないワードには ! は不要です
- !はDEL/DEFの前に置く必要があります（後置記法のため）"#.to_string(),

        "TIMES" => r#"# TIMES - ワードを繰り返し実行

## 機能
指定されたカスタムワードを指定回数だけ繰り返し実行します。
ループ処理を簡潔に記述するための制御フローワードです。

## 使用法
'WORDNAME' [ 回数 ] TIMES
→ ワードを指定回数実行

## 使用例
# カウンタを3回インクリメント
[ '[ 1 ] +' ] 'INC' DEF
[ 0 ] 'INC' [ 3 ] TIMES        # → [ 3 ]

# スタックに値を5回プッシュ
[ '[ 1 ]' ] 'PUSH_ONE' DEF
'PUSH_ONE' [ 5 ] TIMES         # → [ 1 ] [ 1 ] [ 1 ] [ 1 ] [ 1 ]

## 注意
- カスタムワードのみ使用可能（組み込みワードは不可）
- 回数は正の整数である必要があります
- 0回の場合は何も実行されません"#.to_string(),

        "WAIT" => r#"# WAIT - 遅延実行

## 機能
指定したミリ秒後にカスタムワードを実行します。
非同期処理やアニメーションに使用できます。

## 使用法
'WORDNAME' [ ミリ秒 ] WAIT
→ 指定ミリ秒後にワードを実行

## 使用例
# 1秒後にメッセージを出力
[ ''Hello'' PRINT' ] 'SAY_HELLO' DEF
'SAY_HELLO' [ 1000 ] WAIT      # 1000ms後に実行

# 0.5秒後に値を2倍
[ '[ 2 ] *' ] 'DOUBLE' DEF
[ 5 ] 'DOUBLE' [ 500 ] WAIT    # 500ms後に [ 10 ]

## 注意
- カスタムワードのみ使用可能（組み込みワードは不可）
- 遅延時間は正の整数（ミリ秒）である必要があります
- 非同期で実行されるため、後続のコードは待機しません"#.to_string(),

        "SHAPE" => r#"# SHAPE - テンソルの形状を取得

## 機能
テンソルの形状（各次元のサイズ）をベクタとして取得します。
元のテンソルはスタックに残ります。

## 使用法
[ テンソル ] SHAPE
→ [ テンソル ] [ 形状 ]

## 使用例
[ [ 1 2 3 ] [ 4 5 6 ] ] SHAPE  # → [ ... ] [ 2 3 ]  (2行3列)
[ 1 2 3 4 5 ] SHAPE            # → [ ... ] [ 5 ]    (5要素の1次元)
[ [ [ 1 2 ] [ 3 4 ] ] [ [ 5 6 ] [ 7 8 ] ] ] SHAPE
                                # → [ ... ] [ 2 2 2 ] (2x2x2の3次元)

## 注意
- 元のテンソルは消費されません（非破壊的操作）
- 1次元ベクタは単一要素の形状ベクタを返します"#.to_string(),

        "RANK" => r#"# RANK - テンソルの次元数を取得

## 機能
テンソルの次元数（ランク）を取得します。
1次元ベクタはランク1、2次元行列はランク2となります。

## 使用法
[ テンソル ] RANK
→ [ テンソル ] [ ランク ]

## 使用例
[ 1 2 3 4 5 ] RANK             # → [ ... ] [ 1 ]  (1次元)
[ [ 1 2 ] [ 3 4 ] ] RANK       # → [ ... ] [ 2 ]  (2次元)
[ [ [ 1 ] ] ] RANK             # → [ ... ] [ 3 ]  (3次元)

## 注意
- 元のテンソルは消費されません（非破壊的操作）
- SHAPEの結果のLENGTHと同等です"#.to_string(),

        "RESHAPE" => r#"# RESHAPE - テンソルの形状を変更

## 機能
テンソルの要素数を維持したまま、形状を変更します。
行列の次元を変換する際に使用します。

## 使用法
[ テンソル ] [ 新しい形状 ] RESHAPE
→ 形状が変更されたテンソル

## 使用例
[ 1 2 3 4 5 6 ] [ 2 3 ] RESHAPE
# → [ [ 1 2 3 ] [ 4 5 6 ] ]  (6要素 → 2x3行列)

[ [ 1 2 ] [ 3 4 ] [ 5 6 ] ] [ 6 ] RESHAPE
# → [ 1 2 3 4 5 6 ]  (2x3行列 → 6要素)

[ 1 2 3 4 ] [ 2 2 ] RESHAPE
# → [ [ 1 2 ] [ 3 4 ] ]  (4要素 → 2x2行列)

## 注意
- 新しい形状の要素数は元の要素数と一致する必要があります
- 要素数が一致しない場合はエラー"#.to_string(),

        "TRANSPOSE" => r#"# TRANSPOSE - 行列の転置

## 機能
2次元テンソル（行列）の行と列を入れ替えます。

## 使用法
[ 行列 ] TRANSPOSE
→ 転置された行列

## 使用例
[ [ 1 2 3 ] [ 4 5 6 ] ] TRANSPOSE
# → [ [ 1 4 ] [ 2 5 ] [ 3 6 ] ]  (2x3 → 3x2)

[ [ 1 2 ] [ 3 4 ] ] TRANSPOSE
# → [ [ 1 3 ] [ 2 4 ] ]  (2x2行列の転置)

## 注意
- 2次元テンソル（行列）のみ対応
- 1次元ベクタや3次元以上のテンソルはエラー"#.to_string(),

        "CSPRNG" => r#"# CSPRNG - 暗号論的疑似乱数生成

## 機能
暗号論的に安全な疑似乱数を分数として生成します。
分母を指定することで、必要な粒度だけを効率的に生成できます。

## 背景：CSPRNGとPRNGの違い
- **PRNG（疑似乱数生成器）**: シード値から決定論的に生成。高速だが予測可能な場合あり
- **CSPRNG（暗号論的疑似乱数生成器）**: OSのエントロピーソースを使用。予測不可能

この実装はWeb Crypto APIを使用し、暗号論的に安全な乱数を提供します。

## 使用法
CSPRNG                    # デフォルト精度（分母2^32）で1個
[ count ] CSPRNG          # デフォルト精度でcount個
[ denom ] [ count ] CSPRNG  # 分母denomで count個

## 使用例：分母指定モード

# サイコロ（分母6で生成、自動約分される）
[ 6 ] [ 1 ] CSPRNG
# → [ 0 ], [ 1/6 ], [ 1/3 ], [ 1/2 ], [ 2/3 ], [ 5/6 ] のいずれか
#   （内部的には0/6〜5/6だが、約分されて表示）

# サイコロを整数に変換（0〜5）
[ 6 ] [ 1 ] CSPRNG [ 6 ] *
# → [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] のいずれか

# サイコロ（1〜6）
[ 6 ] [ 1 ] CSPRNG [ 6 ] * [ 1 ] +
# → [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ] のいずれか

# コイントス（分母2）
[ 2 ] [ 1 ] CSPRNG
# → [ 0 ] または [ 1/2 ]

# パーセント精度で3個
[ 100 ] [ 3 ] CSPRNG
# → [ 23/100 ] [ 1/2 ] [ 89/100 ] など（約分される場合あり）

## 使用例：デフォルト精度

CSPRNG
# → [ 1234567890/4294967296 ]  (32ビット精度)

[ 3 ] CSPRNG
# → 32ビット精度で3個の乱数

## 分母指定の効率性

分母が小さいほど：
- 結果の分数も小さくなる（約分後）
- 後続の演算（*, +, FLOORなど）が高速
- メモリ使用量も削減

## 技術詳細
- 64ビット余裕を持たせたモジュロ方式（バイアス < 2^-64）
- エントロピーソース: Web Crypto API (crypto.getRandomValues)
- 結果は自動的に既約分数に約分される

## 注意
- Stackモード (..) はサポートされません
- 分母・個数は正の整数である必要があります
- 分数や非整数がスタックにある場合は無視され、デフォルト動作"#.to_string(),

        "HASH" => r#"# HASH - 分数ハッシュ関数

## 機能
任意のAjisai値を決定論的にハッシュ化し、[0, 1)範囲の分数として返します。
分数システムを活用した効率的かつ強力なハッシュアルゴリズムを実装しています。

## 特徴
- **決定論的**: 同じ入力は常に同じハッシュを生成
- **正規形認識**: 1/2と2/4は同じ分数なので同じハッシュ
- **分数出力**: ハッシュ値は [0, 1) の範囲の分数として返される
- **可変長出力**: 32ビットから1024ビットまで指定可能

## 使用法
値 HASH                    # デフォルト256ビット
[ bits ] 値 HASH           # 指定ビット数で出力

## 使用例

# 文字列のハッシュ
'hello' HASH
# → [ 12345.../115792089... ]  (256ビット)

# ベクタのハッシュ
[ 1 2 3 ] HASH
# → [ ... ]

# 分数のハッシュ（正規形を使用）
[ 1/2 ] HASH
[ 2/4 ] HASH
# → 両方同じ結果（1/2と2/4は同値）

# ビット数を指定
[ 128 ] 'hello' HASH
# → 128ビットハッシュ（分母が2^128）

[ 512 ] 'hello' HASH
# → 512ビットハッシュ

# 真偽値のハッシュ
[ TRUE ] HASH
[ FALSE ] HASH
# → 異なるハッシュ

# ネストしたベクタ
[ [ 1 2 ] [ 3 4 ] ] HASH
# → ネスト構造も含めてハッシュ

## ハッシュの用途

# データ整合性チェック
[ 'データ' ] HASH 'ORIGINAL_HASH' DEF
# ... 後で検証
[ 'データ' ] HASH ORIGINAL_HASH =
# → [ TRUE ] なら改ざんなし

# 一意識別子の生成
'ユーザーID_タイムスタンプ' HASH

# ハッシュテーブルのキー生成
[ 128 ] 'キー' HASH [ 1000 ] * FLOOR
# → 0-999のバケットインデックス

## アルゴリズム詳細

### 多項式モジュラーハッシュ
1. 入力値を正規バイト列にシリアライズ
2. 3つの大きな素数（約2^127）で多項式評価
3. 結果を混合してビット拡散
4. 分数（hash / 2^bits）として返す

### なぜ分数が効率的か
- **正規形の活用**: Fraction::new()は自動約分するため、
  同値な分数（1/2 = 2/4）は必ず同じバイト列に
- **任意精度**: BigIntを使うため、どんな大きな値でもハッシュ可能
- **統合性**: 結果が分数なので、他の数学演算とシームレスに連携

## 注意
- Stackモード (..) はサポートされません
- ビット数は32〜1024の範囲で指定
- 暗号的用途（パスワードハッシュなど）には専用アルゴリズムを推奨"#.to_string(),

        _ => {
            // 既存の定義情報にフォールバック
            let definitions = get_builtin_definitions();
            for (word_name, description, category) in definitions {
                if word_name == name {
                    return format!("# {} - {}\n\nCategory: {}\n\n## 説明\n{}\n\n詳細な説明は未実装です。",
                        name, description, category, description);
                }
            }
            format!("ワード '{}' の詳細情報はありません。", name)
        }
    }.to_string()
}
